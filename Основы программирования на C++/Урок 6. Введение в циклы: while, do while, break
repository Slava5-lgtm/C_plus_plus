Урок 6.                                 Введение в циклы: while, do while, break

                                                        Разбор ДЗ прошлого урока.

                                                                ЗАДАЧА -1       (Программ выводит слово рубли в правильном падеже в зависимости от введенного числа)

Попробуем сформулировать условия так что бы было покороче. Когда мы используем форму слово рублей. Мы будем ее использовать когда, если последние цифра числа это
5, 6, 7, 8, 9 или 0. Но не только в этом случае. Еще когда пред последняя цифра десятков равна единицы например 11, 12, 113, 2014.

Если любое из этих условий выполнено то нужно вывести ответ рублей. Поэтому нам потребуется оператор ИЛИ. но как проверить последнею цифру числа.
Нужна взять остаток от деления этого числа на 10.

Например: 2019 % 10 (2019 остаток от деления на 10 это 9) это и есть последняя цифра этого числа. Пишем условия:

// Если остаток от деления на 10 это 0 ИЛИ остаток от деления на 10 больше больше или равена 5 то в этом случаи мы выводим ответ n рублей

if (n % 10 == 0 || n % 10 >= 5){        //  Если остаток от деления на 10 это 0 ИЛИ остаток от деления на 10 больше больше или равна 5
    std::cout << n << " рублей \n";     //  то в этом случаи мы выводим ответ n рублей
}

Еще осталось дописать случай когда предпоследняя была равна единицы. Можно отбросить последнею цифру потом проверить то что осталось. Что бы отбросить последнею цифру
нужно поделить число на 10.

например: 2014 / 10 == 201, потом у числа 201 можно взять последнею цифру то ест остаток от деления на 10 и получится 1. Надо дополнить наше условия

 f (n % 10 == 0 || n % 10 >= 5 || (n / 10) % 10 == 1) {        //  Если остаток от деления на 10 это 0 ИЛИ остаток от деления на 10 больше больше или равен 5 ИЛИ
                                                                 предпоследнии цифра равна 1 То есть число с отброшенной последне цифрой остаток от деления на 10 равен 1
                                                                 чтобы читалось лучше поставим скобки  (n / 10) % 10 == 1
    std::cout << n << " рублей \n";     //  то в этом случаи мы выводим ответ n рублей
 }

Мы разобрали самый сложный способ. Какие остались не разобраны, остались не разобраны только два. Либо последняя цифра была равна единицы и тогда ответ будет рубль
либо она была  диапазоне от двух до четырёх и тогда ответ будет рубля. Второе условия:

  else if (n % 10 == 1) {               // если последняя цифра равна единицы
    std::cout << n << " рубль\n";       // выводим ответ рубль
  }
если последняя цифра равна единцы выводим ответ рубль. И остался последний случай когда последняя цифра лежит в диапазоне от двух до четырех и тогда ответ будет рубля
поскольку это последний не разоброный случай писать условия не надо и можно сразу вывести ответ

else {
    std::cout << n << " рубля\n";
  }


#include <iostream>

int main() {
  int n;
  std::cout << "Введите количество рублей:\n";
  std::cin >> n;

  if (n % 10 == 0 || n % 10 >= 5 || (n / 10) % 10 == 1){
    std::cout << n << " рублей\n";
  }  else if (n % 10 == 1) {
    std::cout << n << " рубль\n";
  } else {
    std::cout << n << " рубля\n";
  }
}

                                                                    Результат

ведите количество рублей:
2011
2011 рублей

                                                                    Результат

Введите количество рублей:
3333
3333 рубля

                                                                    Результат

Введите количество рублей:
1000000000
1000000000 рублей

                                                                ЗАДАЧА -2       (Грустное не совершеннолетия (Нвм с клавиатуре вводят 6 цифр. Сначала день, месяц и год
                                                                                 рождения посетителя, а затем текушию дату. Можно ли ему продавать алкоголь))


#include <iostream>

int main() {
  int day;
  int month;
  int year;
  std::cout << "Введите день, месяц и год рождения посетителя: ";
  std::cin >> day >> month >> year;

  int currentYear;
  int currentMonth;
  int currentDay;
  std::cout << "Введите текущий день, месяц и год: ";
  std::cin >> currentDay >> currentMonth >> currentYear; // текущая дата
  
  /* Мы назвали так переемные что бы знать текушию дату (currentDay, currentMonth, currentYear) и ту что нужно проверить (day, month, year) (сово current обозначает     
     текущий) 
     
     В каком условии можно считать посетителя совершеннолетним очевидно если разность между текущим годом и годом рождения равна или больше восемнадцати то точно можно, а если
     она меньше восемнадцати то точно нельзя мы можем отбросить эти случаи чтобы не думать о них */

  if (currentYear - year < 18) {        // Если текущий год меньше года рождения
    std::cout << "Нельзя";              // нельзя
  } else if (currentYear - year > 18){  // Если текущий год больше года рождения
    std::cout << "Можно";               // можно
  

    /* Осталось разобрать случай когда эта разность равна восемнадцати тогда надо проверить был у посетителя в этот день, день рождения ил нет. Как это делать. Нужно
    сравнить текущий месяц и месяц его рождения. Если текущий месяц больше месяцу его рождения тогда сразу да, а если и текущии месяцы равны тогда проверяем дату
    
    Как записать это одним условием нам пригодиться оба логические оператора И (||) и ИЛИ (&&) */
  } else if (currentMonth > month || currentMonth == month && currentDay > day) {    /* (текущий месяц (currentMonth) , больше месяца рождения (month) ИЛИ (||) текущий
                                                                                         месяц равен месяцу рождения (currentMonth == month) И (&&) текущий день больше дня
                                                                                         рождения (currentDay > day)
                          чтобы легчи читать это длинное условия возьмём взять его в скобки else if (currentMonth > month || (currentMonth == month && currentDay > day)) */
    std::cout << "Можно";                                                            // В этом случае ответ можно

    // Остался последний случай когда в этом году посетителю должно исполниться восемнадцать но еще не исполнилось но поскольку все остальные случаи мы уже перебрали то  как
    обычно последний условия можно не проверять:
    
  } else {
    std::cout << "Нельзя";  // Просто выводим ответ Нельзя
  }
}

                                                                    Результат
Введите день, месяц и год рождения посетителю: 19 2 1994
Введите текущий день, месяц и год: 19 2 2012
Нельзя

                                                                    Результат

Введите день, месяц и год рождения посетителю: 
19 2 1994 
Введите текущий день, месяц и год: 5 8 2012
Можно

                                                                    Результат

Введите день, месяц и год рождения посетителю: 19 2 1994
Введите текущий день, месяц и год: 1 1 3000
Можно


                                         ЦИКЛЫ WHILE (while) (цикл с ПРЕДУСЛОВИЕМ)
                                         
Цикл while - условия проверяться перед тем как выполнить тело цикла. Если условия изначально не выполнилось то тело цикла не будет выполнен не разу

Прежде чем приступить к новой теме посмотрим программы которые мы научились писать. Сначала все наши программы состояли из последующих команд которые мы писали друг за
другом через точку с запятой. И выполнения такой программы могло идти одним путем строчка за строчкой компьютер. выполнял все наши команды одну за другой не чего не
пропуская и не перескакивая такие программы называются - ЛИНЕЙНЫМИ. Это названия происходит от того, что программу можно изобразит в виде цепочки команд выстроены в
одну линию путь выполнения такой программы единственно возможный не каких отклонений у нее не допускается

                                                НАПРИМЕР: Линейный алгоритм

                                                        Действие 1
                                                            |
                                                            |
                                                            | 
                                                        Действие 2
                                                            |
                                                            |
                                                            | -> 
                                                        Действие 3
                                                            |
                                                            |
                                                        Действие 4 

Потом мы научились менять поведения наших прогарам в зависимости от тех или иных условий. В таких программах выполния может идти уже разными путями. Например если
пользователь введет одно число то будет выполняться одни команды, а если другое число то другие команды. Такие программы иногда называются разветвленными.
Если изобразить такую программу в виде схемы то можно увидит что, путь выполнения этой программы в какой то момент раздваивается потом он может раздавиться еще и еще
раз. Эти моменты когда путь выполнения программы раздваиваются называются ВЕТВЛЕНИЕМ, а сами пути которые при этом получаются называются ВЕТКАМИ. Например: если в
нашей программе было условия a > b, то у нас образуется две ветки. Одна на случай если это условие было выполнена и другая  на случай если условие было не выполнена.
У таких программ уже не один, а несколько возможных результатов выполнения потому что в зависимости введенных данных выполнения программы может пойти по разным веткам.

                                                НАПРИМЕР: Разветвляющийся алгоритм


                                                      Действие 1
                                                          |
                                                          |
                                    ----------------Проверка условия----------
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                Действие 2                              Действие 3
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                    ------------------------------------------
                                                          |
                                                          |
                                                      Действие 4

Но оказываеться что большенство задач нельзя решить ни линейными ни развлетвлеными алгоримоми. Дело в ом что их выполнения может идти только сверху вниз. Но очень часто
бывает необходимо вернутся н несколько строк вверх и повторить все еще раз начиная с некоторого места.
Поэтому мы разучим еще одну канструкцию которая как раз позволяет это делать. Такая конструкция называеться: Циклом, а програма которая ее содержит называеться:
ЦИКЛИЧЕСКИМи

                                               НАПРИМЕР: Циклический алгоритм 

                                                      Действие 1
                                                          |
                                                          |
                                              ----->Проверка условия-----
                                              |           |             |
                                              |           |             |
                                              |       Действие 2        |
                                              |           |             |
                                              |           |             |
                                              |-------Действие 3        |
                                                                        |
                                                                        |
                                                                        |
                                                          ---------------
                                                          |
                                                          |
                                                          \/
                                                      Действие 4

Все програмы которые мы использум в жизни это циклические програмы расмотрим простой пример


                                                                ЗАДАЧА -3       (Ввести пароль компьютера если не правильный идет сообщения и сново просит ввести пароль
                                                                                 и так повторяется пока не введешь правильный пароль)


#include <iostream>

int main() {
  std::string password;
  std::cout << "Введите пароль: ";
  std::cin >> password;


  /* Пусть наш пароль это 12345 и пока мы не введем верный пароль программа будет запрвшивать пароль. Пока совподеный пароль не совподет с правильным нужно
     повторять просьбу ввести пароль. Введеный пароль не совподает с правильным это некоторое условия, а попросить ввести пароль пока не совподает с правильным это
     действие которе должна повторять программа пока условие выполнено. По сути мы хотим запичать следушее. Пока некоьорые условия выполнены нужно повторять
     некоторые действия   */
  

  /* Пусть наш пароль это 12345 и пока мы не введем верный пароль программа будет запрвшивать пароль. Пока совподеный пароль не совподет с правильным нужно
  повторять просьбу ввести пароль. */

  
  /* Введеный пароль не совподает с правильным это некоторое условия, а попросить ввести пароль пока не совподает с правильным это действие которе должна повторять
     программа пока условие выполнено. По сути мы хотим напичать следушее. Пока некоторые условия выполнены нужно повторять некоторые действия. Для записи такой
     конструкции в языке С++ есть специальное слово  while которое какраз обозначает пока. Записываеться это буквально так */

  /* пока (условоя) 
  while (условоя) {
    действие (может быть любой код, может быть одно действие, может быть несколько вподряд действий, ф могут быть вложеные блока кода).
  }
    Вся эта конструкция начиная с словом (while) и заканчиваюшиеся фигурной скобкой } наззаваеться циклом, а блок кода (условоя) телом цикла. И все это действует по   
    следушиму правилу. Снчало провиряеться условия в скобках если оно ложно то тело цикла не выполниться не разу. Програа идет дальше. Если условия истина, тело   
    цикла выполняеться, а затем программа возврашяеться к аалу цикла и проверяет условия. Если и на этот раз оно ложно, то больше тело цикла не повторяеться и   
    программа идет дальше если оно опять истина то тело цикла овторяеться еше раз а потом сново проверяеться условия и так мжет проверяться десятки тычячи раз пока  
    условия наконецто не станет ложно.  Используя конструкцию while давайте реализуем программу проверки пороля
    И так мы спросили у пользователя пароль и теперь если н не совподает с правильным. Мы попросим ввести папроль еще раз и.т.д. если пароль сразу совпал то   
    спрашивать больше не чего не нужно. имено это нам и позволить конструкция while, и так запишим. */

    while (password != "12345") {
    std::cout << "Введите пароль:\n";
    std::cin >> password;
  }

  /* Мы говорили что цикл может повторяться милионы раз пока условия не станет ложным, но как оно из истины может стать ложным. А вот как это происходит потому что  
     после каждого выполнения цикла заново вводиться переменая  password и она же проверяеться в условии. Это значит что это условия (password != "12345") 
     проверяеться каждый раз заново и в какойто момент оно может стать ложным. В этот момент выполнения цикла прекратиться и мы пойдем дальше. Для нас это будет
     озночать что наконец то введен правильный пароль. И поэтому об этом можно сообшить пользувателю */
  
  std::cout << "Пароль верный!\n";

                                                  // Запскаем и проверяем как это работает


                                                                    Результат

Введите пароль: 1
Введите пароль:
12
Введите пароль:
123
Введите пароль:
1234
Введите пароль:
65412
Введите пароль:
12345
Пароль верный!


Повторения одного и того же цикла называеться ИТЕРАЦИЯ этого цыкла. Одной итерацией называеться выполненияодного цикла целиком. Без циклов не обойтись когда от
пользователя требуеться ввод большого количество однотипных данных целеком или наоборот когда требуеться вывести пользувателю большое количество данных. Разбереп пример
говорят что бы быстрее уснуть полезно считать овец.

                                                                ЗАДАЧА -3       (Выедим на экран 100 раз через забор перепрыгнула овца)

#include <iostream>

int main() {
  int count = 0;  // счетчик
  while (count < 100) {
    std::cout << "Через забор перепригнула овца" << count << "\n";   /* Чтобы вывсти это сообшения в подрят 100 раз можно его скопировать сто раз. Но можно это сделать
    одним коротким циклом. Поместим это действия в внутырь цикл. Но как выввести это сообшения 100 раз. Нам нужно написать пока (while (какието условия не выполнено) на
    нужно повторять ввывод вот этого сообшения)
    теперь нужно поумать каким должно быть условия. Условия должно быть таким пока мы еще не вывели это сообшения 100 раз продолжать его выводить. Но как сформулировать
    что мы его невывели 100 раз заведем еше одну переменую count из наально она равна нулю. Теперь нам нужно что бы после каждого прижка овцы наша переменая увеличелась
    на еденицу. Потому что мы вывели это сообшения еще раз. Это значит что в цикле помимо вывода сообшения будет еще одно действия */
    count += 1;

    /* Теперь можно понять каким должно быть условия нашего цикла. Оно длжнобыть пока мы не насчитали сто раз тоесть пока наш (count меньше 100). Как только count
    станет равна 100 цикл перестанит выполняться и програма завершиться. Такая переменая называеться счетчик */
  }
}

                                      /* Запустим програму и проверим как оа работает

Мы видим как сообшения ввывелось много раз, а сколько не известно. добавим еше кода чтобы наши овци дествительно считались. С каждой овцой ввыводился ее номер. У нас
есть переменая  count который этот номер и содержит и мы бы могли вывести знчение этой переменой на экран сразу псле нашео сообшения давай так и зделаем. Строка 6 было
так  std::cout << "Через забор перепригнула овца\n"; , а стало так. */

                                                                    Результат

 Через забор перепригнула овца: 0 
 Через забор перепригнула овца: 1 
 Через забор перепригнула овца: 2 
 Через забор перепригнула овца: 3 
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|--|-|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|--|-|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|--|-|
 Через забор перепригнула овца: 94 
 Через забор перепригнула овца: 95 
 Через забор перепригнула овца: 96 
 Через забор перепригнула овца: 97 
 Через забор перепригнула овца: 98 
 Через забор перепригнула овца: 99


                                        Циклы do whil (цикл с постусловием)  
                                        

Сначало выполняються действие в цикле и только затем провиряеться условие. И если оно истина то действие выполняеться еще раз. Главное отлисие цикла с предусловием в 
том, что в цикое с постусловием тело цикла будет выполнено хотябы один раз и только после этого будет провиряться условия. 
 Для записи цикл с постусловием в С++ сушествует конструкция do whil.
 
                                                Она записываеться так:

do {
  затем блок кода
} whil (условия);

В качетве примера решим задачу ввести пароль компьютера если не правильный идет сообщения и снова просит ввести пароль и так повторяется пока не введешь правильный
пароль

                                                                ЗАДАЧА -5       (Ввести пароль компьютера если не правильный идет сообщения и снова просит ввести пароль
                                                                                 и так повторяется пока не введешь правильный пароль (с применением цикла (do while)))


/* Посмотрим на наш старый код

#include <iostream>

int main() {
  std::string password;
  std::cout << "Введите пароль: ";
  std::cin >> password;
  
    while (password != "12345") {
    std::cout << "Введите пароль:\n";
    std::cin >> password;
  }

  std::cout << "Пароль верный!\n"; 
}

                                                                    Результат

Введите пароль: 1
Введите пароль:
12
Введите пароль:
123
Введите пароль:
1234
Введите пароль:
65412
Введите пароль:
12345
Пароль верный!

Можно заметить, что первый раз попросить вести пароль мы должны в любом случае, а вод далше продолжать вводить его мы должны только если текуший введеный пароль был не
правильный поэтому все можно переписать с использованием do while. */


#include <iostream>

int main() {
  std::string password;
  // do
  do {
    std::cout << "Введите пароль: ";
    std::cin >> password;
  // }
  } while (password != "12345"); /* поставили точку с запятой ; {
    std::cout << "Введите пароль:\n";
    std::cin >> password;
  } - а эти строчки не нужны */
  std::cout << "Пароль верный!\n"; 
}


                                                                    Результат

Введите пароль: 4598
Введите пароль: 65987
Введите пароль: 1256
Введите пароль: 12345
Пароль верный!

/* Конструкция do while используетьс очень редко но в некоторых случаях позволяет сделать код короче по сравнением с кодок в котором используеться обычный while. Вот
как в нышей задачи. А что будет если условия в цикле не когда не станет ложным */

/* Напмшем пример 1 меньше 2. Будим выводить сообшение        */

#include <iostream>

int main() {
  while (1 < 2) {
    std::cout << "Через забор перепрыгнула овца.\n";
  }
}

                                                                    Результат


Через забор перепрыгнула овца.
Через забор перепрыгнула овца.
Чере



                                        Применение цикла while. Инструкция break

                                                                ЗАДАЧА -1       (Пользователь вводит N чисел. Найти сумму чисел)

//  Начало очевидно сначало спрашиваем количество чисел.

#include <iostream>

int main() {
  int count;
  std::cout << "Сколько чисел вы хотите просумировать?\n";
  std::cin >> count;

  // Теперь надо попросить пользователя ввести сами эти числа.

  std::cout << "Хорошо введите " << count << " чисел:\n";

  /* Для этого нам надо count раз повторить одно и тоже действие ввести число с клавиатуры. Очевидно нам нужен цикл. Нам нужно чтобы это действие повторилось ровно
  count раз. Для этого нам может помоч перееная счетчик которым мы будем считать количество исполнений этого цикла. Посколько слово count уже исползовано назавем его
  iteration. Потомучто по смыслу в нем будет храниться количесство раз то есть итераций каторый наш цикл уже отработал. Изначально оно равно нулю потом после каждого
  ввода числа количество итерций мы увеличиваем на один  Итак пишем:  */

  int iteration = 0;
  int sum = 0;
  // Пока while () {}  */
  while (iteration < count) {
    // Будем вводить какоето число с клавиатуры и записывать его в переменную number.
    int number; // Созадем переменную number для этого числа.
    std::cin >> number; // Вводим число с клавиатуры.
    std::cin >> number;
    sum += number;
    iteration += 1; // Увеличиваем счетчик итераций на один.

    /*  И теперь мы уже знает что условия цикла будет выглидить так:
    пока количство итерций меньше чем нужо
    while (iteration < count) {
      int number;
      std::cin >> number;
      iteration += 1;
    } как только количество итераций станет равно count мы перестанем вводит числа. К этому времени их будет введено ровно count.
    
    Теперь наша программа просит у пользователя число count, а дальше count раз просит ввести очередное число.
    
    Но как нам подситать сумму  всех этих чисел? Заведем для этого еще одну переменую назавем е sam из начально она будет равна нулю.
    
    int sum = 0
    
    И на каждой итерации цифры мы будем добовлять к этой переменой то число которое сейчас нам ввел пользовател. Тоесть после того как нам ввели очередное число мы
    будем делать:

    std::cin >> number;
    sum += number;

    Таким оброзом после того как цикл будет завершон в переменой sum будет храниться сумма всех введеных чисел. Ведь на каждой итерации мы добовляли к ней очередное
    число ну и в конце програмы нужно вывести ответ:

    std::cout  "СУмма оавна " << sum;
    
    
    */
  }
}

                                                                    Результат


Сколько чисел вы хотите просумировать?
3
Хорошо введите 3 чисел:
20 10 30
Сумма равна 60


                                                                ЗАДАЧА -2       (Возвидения числа в степень)

/*  Для начало попросим пользоавиеля ввести основание степени и показатель степени */

#include <iostream>

int main() {
  int a;
  std::cout << "Введите основание тепени:\n";
  std::cin >> a;

  int b;
  std::cout << "Введите показатель тепени:\n";
  std::cin >> b;

  /* Теперь нам опять потребуеться цыкал для того что бы, уможить переменую (а) саму на себя (b) раз */

  int iteration = 0;

  /* Назавем переменую result чтобы записывать результат. Чему она должна быть равна изначально? Если бы переменая была равна нулю и мы бы не разу не выполнялт цикл то
  ответом был бы 1. Потому что любое число в нулевой степени это еденица. Значит переменая result = 1 */
  int result = 1;
  
 /* Повторение будет b раз. */
  while (iteration < b) {

    /* И на каждом повторении мы должны result умнажать на (а) таким оброзом когда цыкл закончет проверяться в result будет значения (а) умножено саму на себя столько раз
    сколькоповторился цикл, а цикл повторился (b) раз */
    result *= a;
    iteration += 1;
  }
    std::cout <<  "Результат равен " << result;

}

                                                                    Результат

Введите основание тепени:
2
Введите показатель тепени:
3
Результат равен 8


Для решения большенство задач в програмировании так или иначе исользуються циклы. Задачи которые мырасматривали до этого циклы напрашивался сам собой прямо из условия нужно
было повтроить определеное количство действия определеное количство раз. Сейчас мы расмотрим пару примеров задач где из условий сразу может быть не очевидно, что здесь нужен
цикл. 
Однако при детальном расмотрении видно что цикл необходим.


                                                                ЗАДАЧА - 3       Пользователь вводит положительное целое число, а програма ввыводит сумму этого числа


Например 361 - 10, 250 - 7, 364 - 13, 1000000 - 1


/* Для начало попросим пользователя ввести число  

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;

  Мы хотим подсчитать сумму цифр в числе логичней всего это делать так:
     Завести переменую sum с начальным значенем ноль.  

  int sum = 0;

   А затем прибовлять к ней по очереди значния цифр этого числа одно за другим пока все цифры не будут пощитаны. Но как нам имея число number получить значения какой нибудь
   из его цифр. Мы знаем что очень легко можно получить значения последней цифры. Для этого нужно взять остаток от деления нашего числа на 10. Так и запишем: 

  int lastDigit = number % 10;

   И это значение мы можем сразу добавить к ответу:
  
  sum += lastDigit;    // к сумме добовляем последнию цифру

   А как теперь получить предпоследнию цифру? Последния цифра нам уже не нужжна мы ее посчитали. Мы можем отрубить от числа последнию цифру
  для этого можно просто поделить его на 10 
  
  number /= 10;
  
  Теперь последняя цифра получившегося числа будет предпоследней цифрой исходного числа
  Мы можем это снова записать в переменую lastDigi. 

  lastDigit = number % 10; // Это будет последнея цифра нашего нового числа

  И мы можем сново добаить ее к ответу 
  
  sum += lastDigit;

  После этого мы можем сново отрубит последнию цифру у числа которе сейчас получилось. 

  number /= 10;
  sum += lastDigit;

  Назреват мысиль что нам нужно повторять эти же действия:
  
  lastDigit = number % 10; 
  sum += lastDigit;
  number /= 10;
  
  еще неколько раз пока выполнено некоторое условия. 
  Что это за условия? нам нужно будет закончить в тот момент кагда число number стонет равно нулю. Тоесть все цифры мы уже у него отрубили, а значит повторять наши действия
  надо пока number неравн нулю. 
  Запишим это в виде цикла: 

  while (number != 0) {            // пока number не равно нулю
    
    lastDigit = number % 10;       // мы
    sum += lastDigit;              // повторяем 
    number /= 10;                  // эти действия
  }
  Можно заметить что наши начальные действия
  
  int lastDigit = number % 10;
  sum += lastDigit
  number /= 10;

  Тоже почти дословно повторяют тело цикла. Разница лишь в том что в цикле используем переменую lastDigit, а объявили мы ее перед тем как зайти в цикл. Но на самом деле можно
  обойтись без этой переменой, а можно сразу добовлять к ответу значения выражений number % 10 ( остаток от деления на 10) не сохроняя его перед этим в переменой  lastDigit.

  Поэтому мы можем упростить код 

    while (number != 0) {            
    
      // lastDigit = number % 10;    - и вот это действия в нем не нужно
      sum += lastDigit;             
      number /= 10;

  Тоже самое и здесь:

  sum += lastDigit; чтобы добовлять lastDigit, мы можем сразу добовлять sum += number % 10; И получаеться переменая lastDigit нам совсем не нужа теперь мы видим что наши
  действия перед циклом

  
  

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;
  
  int sum = 0;
  sum += number % 10;
  number /= 10;
  while (number != 0) {
    sum += number % 10;
    number /= 10;
  }

Теперь мы видим что наши действия перед циклом полностью повторяют тело цикла, а значит их можно полностью удолить

  int sum = 0;           
  sum += number % 10;    - удоляем  
  number /= 10;          - удоляем
  while (number != 0) {
    sum += number % 10;
    number /= 10;*/



#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;
  
  int sum = 0;
  while (number != 0) {
    sum += number % 10;
    number /= 10;
  }

  // И осталось вывести только ответ:
  
  std::cout << "Сумма цифр в числе равна: " << sum;
}


                                                                    Результат

Введите положительное число без нулей в начале:
361
Сумма цифр в числе равна: 10

                                                                    Результат

ведите положительное число без нулей в начале:
250
Сумма цифр в числе равна: 7


                                                                    Результат

Введите положительное число без нулей в начале:
364
Сумма цифр в числе равна: 13

                                                                    Результат

Введите положительное число без нулей в начале:
1000000
Сумма цифр в числе равна: 1

                                                                ЗАДАЧА - 4       Дано положительно целое число и надо проверить являеться оно простым числом