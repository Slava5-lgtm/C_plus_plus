Урок 6.                                 Введение в циклы: while, do while, break

                                                        Разбор ДЗ прошлого урока.

                                                                ЗАДАЧА -1       (Программ выводит слово рубли в правильном падеже в зависимости от введенного числа)

Попробуем сформулировать условия так что бы было покороче. Когда мы используем форму слово рублей. Мы будем ее использовать когда, если последние цифра числа это
5, 6, 7, 8, 9 или 0. Но не только в этом случае. Еще когда пред последняя цифра десятков равна единицы например 11, 12, 113, 2014.

Если любое из этих условий выполнено то нужно вывести ответ рублей. Поэтому нам потребуется оператор ИЛИ. но как проверить последнею цифру числа.
Нужна взять остаток от деления этого числа на 10.

Например: 2019 % 10 (2019 остаток от деления на 10 это 9) это и есть последняя цифра этого числа. Пишем условия:

// Если остаток от деления на 10 это 0 ИЛИ остаток от деления на 10 больше больше или равена 5 то в этом случаи мы выводим ответ n рублей

if (n % 10 == 0 || n % 10 >= 5){        //  Если остаток от деления на 10 это 0 ИЛИ остаток от деления на 10 больше больше или равна 5
    std::cout << n << " рублей \n";     //  то в этом случаи мы выводим ответ n рублей
}

Еще осталось дописать случай когда предпоследняя была равна единицы. Можно отбросить последнею цифру потом проверить то что осталось. Что бы отбросить последнею цифру
нужно поделить число на 10.

например: 2014 / 10 == 201, потом у числа 201 можно взять последнею цифру то ест остаток от деления на 10 и получится 1. Надо дополнить наше условия

 f (n % 10 == 0 || n % 10 >= 5 || (n / 10) % 10 == 1) {        //  Если остаток от деления на 10 это 0 ИЛИ остаток от деления на 10 больше больше или равен 5 ИЛИ
                                                                 предпоследнии цифра равна 1 То есть число с отброшенной последне цифрой остаток от деления на 10 равен 1
                                                                 чтобы читалось лучше поставим скобки  (n / 10) % 10 == 1
    std::cout << n << " рублей \n";     //  то в этом случаи мы выводим ответ n рублей
 }

Мы разобрали самый сложный способ. Какие остались не разобраны, остались не разобраны только два. Либо последняя цифра была равна единицы и тогда ответ будет рубль
либо она была  диапазоне от двух до четырёх и тогда ответ будет рубля. Второе условия:

  else if (n % 10 == 1) {               // если последняя цифра равна единицы
    std::cout << n << " рубль\n";       // выводим ответ рубль
  }
если последняя цифра равна единцы выводим ответ рубль. И остался последний случай когда последняя цифра лежит в диапазоне от двух до четырех и тогда ответ будет рубля
поскольку это последний не разоброный случай писать условия не надо и можно сразу вывести ответ

else {
    std::cout << n << " рубля\n";
  }


#include <iostream>

int main() {
  int n;
  std::cout << "Введите количество рублей:\n";
  std::cin >> n;

  if (n % 10 == 0 || n % 10 >= 5 || (n / 10) % 10 == 1){
    std::cout << n << " рублей\n";
  }  else if (n % 10 == 1) {
    std::cout << n << " рубль\n";
  } else {
    std::cout << n << " рубля\n";
  }
}

                                                                    Результат

ведите количество рублей:
2011
2011 рублей

                                                                    Результат

Введите количество рублей:
3333
3333 рубля

                                                                    Результат

Введите количество рублей:
1000000000
1000000000 рублей

                                                                ЗАДАЧА -2       (Грустное не совершеннолетия (Нвм с клавиатуре вводят 6 цифр. Сначала день, месяц и год
                                                                                 рождения посетителя, а затем текушию дату. Можно ли ему продавать алкоголь))


#include <iostream>

int main() {
  int day;
  int month;
  int year;
  std::cout << "Введите день, месяц и год рождения посетителя: ";
  std::cin >> day >> month >> year;

  int currentYear;
  int currentMonth;
  int currentDay;
  std::cout << "Введите текущий день, месяц и год: ";
  std::cin >> currentDay >> currentMonth >> currentYear; // текущая дата
  
  /* Мы назвали так переемные что бы знать текушию дату (currentDay, currentMonth, currentYear) и ту что нужно проверить (day, month, year) (сово current обозначает     
     текущий) 
     
     В каком условии можно считать посетителя совершеннолетним очевидно если разность между текущим годом и годом рождения равна или больше восемнадцати то точно можно, а если
     она меньше восемнадцати то точно нельзя мы можем отбросить эти случаи чтобы не думать о них */

  if (currentYear - year < 18) {        // Если текущий год меньше года рождения
    std::cout << "Нельзя";              // нельзя
  } else if (currentYear - year > 18){  // Если текущий год больше года рождения
    std::cout << "Можно";               // можно
  

    /* Осталось разобрать случай когда эта разность равна восемнадцати тогда надо проверить был у посетителя в этот день, день рождения ил нет. Как это делать. Нужно
    сравнить текущий месяц и месяц его рождения. Если текущий месяц больше месяцу его рождения тогда сразу да, а если и текущии месяцы равны тогда проверяем дату
    
    Как записать это одним условием нам пригодиться оба логические оператора И (||) и ИЛИ (&&) */
  } else if (currentMonth > month || currentMonth == month && currentDay > day) {    /* (текущий месяц (currentMonth) , больше месяца рождения (month) ИЛИ (||) текущий
                                                                                         месяц равен месяцу рождения (currentMonth == month) И (&&) текущий день больше дня
                                                                                         рождения (currentDay > day)
                          чтобы легчи читать это длинное условия возьмём взять его в скобки else if (currentMonth > month || (currentMonth == month && currentDay > day)) */
    std::cout << "Можно";                                                            // В этом случае ответ можно

    // Остался последний случай когда в этом году посетителю должно исполниться восемнадцать но еще не исполнилось но поскольку все остальные случаи мы уже перебрали то  как
    обычно последний условия можно не проверять:
    
  } else {
    std::cout << "Нельзя";  // Просто выводим ответ Нельзя
  }
}

                                                                    Результат
Введите день, месяц и год рождения посетителю: 19 2 1994
Введите текущий день, месяц и год: 19 2 2012
Нельзя

                                                                    Результат

Введите день, месяц и год рождения посетителю: 
19 2 1994 
Введите текущий день, месяц и год: 5 8 2012
Можно

                                                                    Результат

Введите день, месяц и год рождения посетителю: 19 2 1994
Введите текущий день, месяц и год: 1 1 3000
Можно


                                         ЦИКЛЫ WHILE (while) (цикл с ПРЕДУСЛОВИЕМ)
                                         
Цикл while - условия проверяться перед тем как выполнить тело цикла. Если условия изначально не выполнилось то тело цикла не будет выполнен не разу

Прежде чем приступить к новой теме посмотрим программы которые мы научились писать. Сначала все наши программы состояли из последующих команд которые мы писали друг за
другом через точку с запятой. И выполнения такой программы могло идти одним путем строчка за строчкой компьютер. выполнял все наши команды одну за другой не чего не
пропуская и не перескакивая такие программы называются - ЛИНЕЙНЫМИ. Это названия происходит от того, что программу можно изобразит в виде цепочки команд выстроены в
одну линию путь выполнения такой программы единственно возможный не каких отклонений у нее не допускается

                                                НАПРИМЕР: Линейный алгоритм

                                                        Действие 1
                                                            |
                                                            |

                                                            |
                                                            |
                                                            | -> 
                                                        Действие 3
                                                            |
                                                            |
                                                        Действие 4 

Потом мы научились менять поведения наших прогарам в зависимости от тех или иных условий. В таких программах выполния может идти уже разными путями. Например если
пользователь введет одно число то будет выполняться одни команды, а если другое число то другие команды. Такие программы иногда называются разветвленными.
Если изобразить такую программу в виде схемы то можно увидит что, путь выполнения этой программы в какой то момент раздваивается потом он может раздавиться еще и еще
раз. Эти моменты когда путь выполнения программы раздваиваются называются ВЕТВЛЕНИЕМ, а сами пути которые при этом получаются называются ВЕТКАМИ. Например: если в
нашей программе было условия a > b, то у нас образуется две ветки. Одна на случай если это условие было выполнена и другая  на случай если условие было не выполнена.
У таких программ уже не один, а несколько возможных результатов выполнения потому что в зависимости введенных данных выполнения программы может пойти по разным веткам.

                                                НАПРИМЕР: Разветвляющийся алгоритм



                                                      Действие 1
                                                          |
                                                          |
                                    ----------------Проверка условия----------
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                Действие 2                              Действие 3
                                    |                                        |
                                    |                                        |
                                    |                                        |
                                    ------------------------------------------
                                                          |
                                                          |
                                                      Действие 4

Но оказываеться что большенство задач нельзя решить ни линейными ни разветвленными алгоримоми. Дело в ом что их выполнения может идти только сверху вниз. Но очень часто
бывает необходимо вернутся н несколько строк вверх и повторить все еще раз начиная с некоторого места.
Поэтому мы разучим еще одну канструкцию которая как раз позволяет это делать. Такая конструкция называеться: Циклом, а програма которая ее содержит называеться:
ЦИКЛИЧЕСКИМи

                                               НАПРИМЕР: Циклический алгоритм 

                                                      Действие 1
                                                          |
                                                          |
                                              ----->Проверка условия-----
                                              |           |             |
                                              |           |             |
                                              |       Действие 2        |
                                              |           |             |
                                              |           |             |
                                              |-------Действие 3        |
                                                                        |
                                                                        |
                                                                        |
                                                          ---------------
                                                          |
                                                          |
                                                          \/
                                                      Действие 4

Все програмы которые мы использум в жизни это циклические програмы расмотрим простой пример


                                                                ЗАДАЧА -3       (Ввести пароль компьютера если не правильный идет сообщения и сново просит ввести пароль
                                                                                 и так повторяется пока не введешь правильный пароль)


#include <iostream>

int main() {
  std::string password;
  std::cout << "Введите пароль: ";
  std::cin >> password;


  /* Пусть наш пароль это 12345 и пока мы не введем верный пароль программа будет запрвшивать пароль. Пока совподеный пароль не совподет с правильным нужно
     повторять просьбу ввести пароль. Введеный пароль не совподает с правильным это некоторое условия, а попросить ввести пароль пока не совподает с правильным это
     действие которе должна повторять программа пока условие выполнено. По сути мы хотим запичать следушее. Пока некоьорые условия выполнены нужно повторять
     некоторые действия   */
  

  /* Пусть наш пароль это 12345 и пока мы не введем верный пароль программа будет запрвшивать пароль. Пока совподеный пароль не совподет с правильным нужно
  повторять просьбу ввести пароль. */

  
  /* Введеный пароль не совподает с правильным это некоторое условия, а попросить ввести пароль пока не совподает с правильным это действие которе должна повторять
     программа пока условие выполнено. По сути мы хотим напичать следушее. Пока некоторые условия выполнены нужно повторять некоторые действия. Для записи такой
     конструкции в языке С++ есть специальное слово  while которое какраз обозначает пока. Записываеться это буквально так */

  /* пока (условоя) 
  while (условоя) {
    действие (может быть любой код, может быть одно действие, может быть несколько вподряд действий, ф могут быть вложеные блока кода).
  }
    Вся эта конструкция начиная с словом (while) и заканчиваюшиеся фигурной скобкой } наззаваеться циклом, а блок кода (условоя) телом цикла. И все это действует по   
    следушиму правилу. Снчало провиряеться условия в скобках если оно ложно то тело цикла не выполниться не разу. Програа идет дальше. Если условия истина, тело   
    цикла выполняеться, а затем программа возврашяеться к аалу цикла и проверяет условия. Если и на этот раз оно ложно, то больше тело цикла не повторяеться и   
    программа идет дальше если оно опять истина то тело цикла овторяеться еше раз а потом сново проверяеться условия и так мжет проверяться десятки тычячи раз пока  
    условия наконецто не станет ложно.  Используя конструкцию while давайте реализуем программу проверки пороля
    И так мы спросили у пользователя пароль и теперь если н не совподает с правильным. Мы попросим ввести папроль еще раз и.т.д. если пароль сразу совпал то   
    спрашивать больше не чего не нужно. имено это нам и позволить конструкция while, и так запишим. */

    while (password != "12345") {
    std::cout << "Введите пароль:\n";
    std::cin >> password;
  }

  /* Мы говорили что цикл может повторяться милионы раз пока условия не станет ложным, но как оно из истины может стать ложным. А вот как это происходит потому что  
     после каждого выполнения цикла заново вводиться переменая  password и она же проверяеться в условии. Это значит что это условия (password != "12345") 
     проверяеться каждый раз заново и в какойто момент оно может стать ложным. В этот момент выполнения цикла прекратиться и мы пойдем дальше. Для нас это будет
     озночать что наконец то введен правильный пароль. И поэтому об этом можно сообщить пользователю */
  
  std::cout << "Пароль верный!\n";

                                                  // Запускаем и проверяем как это работает


                                                                    Результат

Введите пароль: 1
Введите пароль:
12
Введите пароль:
123
Введите пароль:
1234
Введите пароль:
65412
Введите пароль:
12345
Пароль верный!


Повторения одного и того же цикла называеться ИТЕРАЦИЯ этого цыкла. Одной итерацией называеться выполненияодного цикла целиком. Без циклов не обойтись когда от
пользователя требуеться ввод большого количество однотипных данных целеком или наоборот когда требуеться вывести пользувателю большое количество данных. Разбереп пример
говорят что бы быстрее уснуть полезно считать овец.

                                                                ЗАДАЧА -4       (Выедим на экран 100 раз через забор перепрыгнула овца)

#include <iostream>

int main() {
  int count = 0;  // счетчик
  while (count < 100) {
    std::cout << "Через забор перепригнула овца" << count << "\n";   /* Чтобы вывсти это сообшения в подрят 100 раз можно его скопировать сто раз. Но можно это сделать
    одним коротким циклом. Поместим это действия в внутырь цикл. Но как выввести это сообшения 100 раз. Нам нужно написать пока (while (какието условия не выполнено) на
    нужно повторять ввывод вот этого сообшения)
    теперь нужно поумать каким должно быть условия. Условия должно быть таким пока мы еще не вывели это сообшения 100 раз продолжать его выводить. Но как сформулировать
    что мы его невывели 100 раз заведем еше одну переменую count из наально она равна нулю. Теперь нам нужно что бы после каждого прижка овцы наша переменая увеличелась
    на еденицу. Потому что мы вывели это сообшения еще раз. Это значит что в цикле помимо вывода сообшения будет еще одно действия */
    count += 1;

    /* Теперь можно понять каким должно быть условия нашего цикла. Оно длжнобыть пока мы не насчитали сто раз тоесть пока наш (count меньше 100). Как только count
    станет равна 100 цикл перестанит выполняться и програма завершиться. Такая переменая называеться счетчик */
  }
}

                                      /* Запустим програму и проверим как оа работает

Мы видим как сообшения ввывелось много раз, а сколько не известно. добавим еше кода чтобы наши овци дествительно считались. С каждой овцой ввыводился ее номер. У нас
есть переменая  count который этот номер и содержит и мы бы могли вывести знчение этой переменой на экран сразу псле нашео сообшения давай так и зделаем. Строка 6 было
так  std::cout << "Через забор перепригнула овца\n"; , а стало так. */

                                                                    Результат

 Через забор перепригнула овца: 0 
 Через забор перепригнула овца: 1 
 Через забор перепригнула овца: 2 
 Через забор перепригнула овца: 3 
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|--|-|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|--|-|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|--|-|
 Через забор перепригнула овца: 94 
 Через забор перепригнула овца: 95 
 Через забор перепригнула овца: 96 
 Через забор перепригнула овца: 97 
 Через забор перепригнула овца: 98 
 Через забор перепригнула овца: 99


                                        Циклы do whil (цикл с постусловием)  
                                        

Сначало выполняються действие в цикле и только затем провиряеться условие. И если оно истина то действие выполняеться еще раз. Главное отлисие цикла с предусловием в 
том, что в цикое с постусловием тело цикла будет выполнено хотябы один раз и только после этого будет провиряться условия. 
 Для записи цикл с постусловием в С++ сушествует конструкция do whil.
 
                                                Она записываеться так:

do {
  затем блок кода
} whil (условия);

В качетве примера решим задачу ввести пароль компьютера если не правильный идет сообщения и снова просит ввести пароль и так повторяется пока не введешь правильный
пароль

                                                                ЗАДАЧА -5       (Ввести пароль компьютера если не правильный идет сообщения и снова просит ввести пароль
                                                                                 и так повторяется пока не введешь правильный пароль (с применением цикла (do while)))


/* Посмотрим на наш старый код

#include <iostream>

int main() {
  std::string password;
  std::cout << "Введите пароль: ";
  std::cin >> password;
  
    while (password != "12345") {
    std::cout << "Введите пароль:\n";
    std::cin >> password;
  }

  std::cout << "Пароль верный!\n"; 
}

                                                                    Результат

Введите пароль: 1
Введите пароль:
12
Введите пароль:
123
Введите пароль:
1234
Введите пароль:
65412
Введите пароль:
12345
Пароль верный!

Можно заметить, что первый раз попросить вести пароль мы должны в любом случае, а вод далше продолжать вводить его мы должны только если текуший введеный пароль был не
правильный поэтому все можно переписать с использованием do while. */


#include <iostream>

int main() {
  std::string password;
  // do
  do {
    std::cout << "Введите пароль: ";
    std::cin >> password;
  // }
  } while (password != "12345"); /* поставили точку с запятой ; {
    std::cout << "Введите пароль:\n";
    std::cin >> password;
  } - а эти строчки не нужны */
  std::cout << "Пароль верный!\n"; 
}


                                                                    Результат

Введите пароль: 4598
Введите пароль: 65987
Введите пароль: 1256
Введите пароль: 12345
Пароль верный!

/* Конструкция do while используетьс очень редко но в некоторых случаях позволяет сделать код короче по сравнением с кодок в котором используеться обычный while. Вот
как в нышей задачи. А что будет если условия в цикле не когда не станет ложным */

/* Напмшем пример 1 меньше 2. Будим выводить сообшение        */

#include <iostream>

int main() {
  while (1 < 2) {
    std::cout << "Через забор перепрыгнула овца.\n";
  }
}

                                                                    Результат


Через забор перепрыгнула овца.
Через забор перепрыгнула овца.
Чере



                                        Применение цикла while. Инструкция break

                                                                ЗАДАЧА -1       (Пользователь вводит N чисел. Найти сумму чисел)

//  Начало очевидно сначало спрашиваем количество чисел.

#include <iostream>

int main() {
  int count;
  std::cout << "Сколько чисел вы хотите просумировать?\n";
  std::cin >> count;

  // Теперь надо попросить пользователя ввести сами эти числа.

  std::cout << "Хорошо введите " << count << " чисел:\n";

  /* Для этого нам надо count раз повторить одно и тоже действие ввести число с клавиатуры. Очевидно нам нужен цикл. Нам нужно чтобы это действие повторилось ровно
  count раз. Для этого нам может помоч перееная счетчик которым мы будем считать количество исполнений этого цикла. Посколько слово count уже исползовано назавем его
  iteration. Потомучто по смыслу в нем будет храниться количесство раз то есть итераций каторый наш цикл уже отработал. Изначально оно равно нулю потом после каждого
  ввода числа количество итерций мы увеличиваем на один  Итак пишем:  */

  int iteration = 0;
  int sum = 0;
  // Пока while () {}  */
  while (iteration < count) {
    // Будем вводить какоето число с клавиатуры и записывать его в переменную number.
    int number; // Созадем переменную number для этого числа.
    std::cin >> number; // Вводим число с клавиатуры.
    std::cin >> number;
    sum += number;
    iteration += 1; // Увеличиваем счетчик итераций на один.

    /*  И теперь мы уже знает что условия цикла будет выглидить так:
    пока количство итерций меньше чем нужо
    while (iteration < count) {
      int number;
      std::cin >> number;
      iteration += 1;
    } как только количество итераций станет равно count мы перестанем вводит числа. К этому времени их будет введено ровно count.
    
    Теперь наша программа просит у пользователя число count, а дальше count раз просит ввести очередное число.
    
    Но как нам подситать сумму  всех этих чисел? Заведем для этого еще одну переменую назавем е sam из начально она будет равна нулю.
    
    int sum = 0
    
    И на каждой итерации цифры мы будем добовлять к этой переменой то число которое сейчас нам ввел пользовател. Тоесть после того как нам ввели очередное число мы
    будем делать:

    std::cin >> number;
    sum += number;

    Таким оброзом после того как цикл будет завершон в переменой sum будет храниться сумма всех введеных чисел. Ведь на каждой итерации мы добовляли к ней очередное
    число ну и в конце програмы нужно вывести ответ:

    std::cout  "СУмма оавна " << sum;
    
    
    */
  }
}
Урок 11. Функции в программировании
                                                                    Результат


Сколько чисел вы хотите просумировать?
3
Хорошо введите 3 чисел:
20 10 30
Сумма равна 60


                                                                ЗАДАЧА -2       (Возвидения числа в степень)

/*  Для начало попросим пользоавиеля ввести основание степени и показатель степени */

#include <iostream>

int main() {
  int a;
  std::cout << "Введите основание тепени:\n";
  std::cin >> a;

  int b;
  std::cout << "Введите показатель тепени:\n";
  std::cin >> b;

  /* Теперь нам опять потребуеться цыкал для того что бы, уможить переменую (а) саму на себя (b) раз */

  int iteration = 0;

  /* Назавем переменую result чтобы записывать результат. Чему она должна быть равна изначально? Если бы переменая была равна нулю и мы бы не разу не выполнялт цикл то
  ответом был бы 1. Потому что любое число в нулевой степени это еденица. Значит переменая result = 1 */
  int result = 1;
  
 /* Повторение будет b раз. */
  while (iteration < b) {

    /* И на каждом повторении мы должны result умнажать на (а) таким оброзом когда цыкл закончет проверяться в result будет значения (а) умножено саму на себя столько раз
    сколькоповторился цикл, а цикл повторился (b) раз */
    result *= a;
    iteration += 1;
  }
    std::cout <<  "Результат равен " << result;

}

                                                                    Результат

Введите основание тепени:
2
Введите показатель тепени:
3
Результат равен 8


Для решения большенство задач в програмировании так или иначе исользуються циклы. Задачи которые мырасматривали до этого циклы напрашивался сам собой прямо из условия нужно
было повтроить определеное количство действия определеное количство раз. Сейчас мы расмотрим пару примеров задач где из условий сразу может быть не очевидно, что здесь нужен
цикл. 
Однако при детальном расмотрении видно что цикл необходим.


                                                                ЗАДАЧА - 3       Пользователь вводит положительное целое число, а програма ввыводит сумму этого числа


Например 361 - 10, 250 - 7, 364 - 13, 1000000 - 1


/* Для начало попросим пользователя ввести число  

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;

  Мы хотим подсчитать сумму цифр в числе логичней всего это делать так:
     Завести переменую sum с начальным значенем ноль.  

  int sum = 0;

   А затем прибовлять к ней по очереди значния цифр этого числа одно за другим пока все цифры не будут пощитаны. Но как нам имея число number получить значения какой нибудь
   из его цифр. Мы знаем что очень легко можно получить значения последней цифры. Для этого нужно взять остаток от деления нашего числа на 10. Так и запишем: 

  int lastDigit = number % 10;

   И это значение мы можем сразу добавить к ответу:
  
  sum += lastDigit;    // к сумме добовляем последнию цифру

   А как теперь получить предпоследнию цифру? Последния цифра нам уже не нужжна мы ее посчитали. Мы можем отрубить от числа последнию цифру
  для этого можно просто поделить его на 10 
  
  number /= 10;
  
  Теперь последняя цифра получившегося числа будет предпоследней цифрой исходного числа
  Мы можем это снова записать в переменую lastDigi. 

  lastDigit = number % 10; // Это будет последнея цифра нашего нового числа

  И мы можем сново добаить ее к ответу 
  
  sum += lastDigit;

  После этого мы можем сново отрубит последнию цифру у числа которе сейчас получилось. 

  number /= 10;
  sum += lastDigit;

  Назреват мысиль что нам нужно повторять эти же действия:
  
  lastDigit = number % 10; 
  sum += lastDigit;
  number /= 10;
  
  еще неколько раз пока выполнено некоторое условия. 
  Что это за условия? нам нужно будет закончить в тот момент кагда число number стонет равно нулю. Тоесть все цифры мы уже у него отрубили, а значит повторять наши действия
  надо пока number неравн нулю. 
  Запишим это в виде цикла: 

  while (number != 0) {            // пока number не равно нулю
    
    lastDigit = number % 10;       // мы
    sum += lastDigit;              // повторяем 
    number /= 10;                  // эти действия
  }
  Можно заметить что наши начальные действия
  
  int lastDigit = number % 10;
  sum += lastDigit
  number /= 10;

  Тоже почти дословно повторяют тело цикла. Разница лишь в том что в цикле используем переменую lastDigit, а объявили мы ее перед тем как зайти в цикл. Но на самом деле можно
  обойтись без этой переменой, а можно сразу добовлять к ответу значения выражений number % 10 ( остаток от деления на 10) не сохроняя его перед этим в переменой  lastDigit.

  Поэтому мы можем упростить код 

    while (number != 0) {            
    
      // lastDigit = number % 10;    - и вот это действия в нем не нужно
      sum += lastDigit;             
      number /= 10;

  Тоже самое и здесь:

  sum += lastDigit; чтобы добовлять lastDigit, мы можем сразу добовлять sum += number % 10; И получаеться переменая lastDigit нам совсем не нужа теперь мы видим что наши
  действия перед циклом

  
  

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;
  
  int sum = 0;
  sum += number % 10;
  number /= 10;
  while (number != 0) {
    sum += number % 10;
    number /= 10;
  }

Теперь мы видим что наши действия перед циклом полностью повторяют тело цикла, а значит их можно полностью удолить

  int sum = 0;           
  sum += number % 10;    - удоляем  
  number /= 10;          - удоляем
  while (number != 0) {
    sum += number % 10;
    number /= 10;*/



#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;
  
  int sum = 0;
  while (number != 0) {
    sum += number % 10;
    number /= 10;
  }

  // И осталось вывести только ответ:
  
  std::cout << "Сумма цифр в числе равна: " << sum;
}


                                                                    Результат

Введите положительное число без нулей в начале:
361
Сумма цифр в числе равна: 10

                                                                    Результат

ведите положительное число без нулей в начале:
250
Сумма цифр в числе равна: 7


                                                                    Результат

Введите положительное число без нулей в начале:
364
Сумма цифр в числе равна: 13

                                                                    Результат

Введите положительное число без нулей в начале:
1000000
Сумма цифр в числе равна: 1

                                                                ЗАДАЧА - 4       Дано положительно целое число и надо проверить являеться оно простым числом


Простое число — натуральное число, имеющее ровно два различных натуральных делителя — единицу и самого себя. Напишем код для решения этой задачи.


#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;

  /* Первоя приходящия в голову идея это подсчитать на какое количество чисел наше исло делиться без остатков. Если наше число простое то таких должно насчитаться ровно два
  наш число и единиться. Как это напиать? Допустим мы хотим проверить число 42 и подсчитать сколько будет делителей без остатка. Сначало проверим делиться ли оно на еденицу
  да делиться, потом проверяем на 2 да опять делиться.
  
  Поэтому нам потребуеться еше две переменые. Первую переменую мы назавем current. Она будет постепено меняться от одного до number и на нее мы будем каждый раз пытаться
  делить. current означает текуший, что ознчаем смысл этой переменой в ней будет записан текуший кандидат которого мы проверяем. */

  int current = 1;

  /* И кроме того нам еще понадобиться переменая count. В ней мы будим считать сколько кондидато было успешных, то есть сколько раз наше число поделилось на current без
  остатка. Изначадьно оно равно нулю тотому что мы еще не чего не проверили или не поделили */
  int count = 0;

  /* Теперь надо написать цикл
  while () {
                                              Что мы будем делать в цикле мы будем проверять делиться ли number на очередное число тоесть на current
    if (number % current == 0) count += 1;    и если делиться то увеличивать count на еденицу

    после этого мы должны увеличит current на еденицу
    current += 1;                             мы должны увеличит current на еденицу что бы на следушей итерации цикла проверять уже другого кандидата
                                              что должно быть условием цикла while () до каких пор мы должны все это дело повторять.
                                              
  Очевидно до тех пор пока наш кандедат current не станет болше чем исходное число number Если current больше number то болше повторять циклне надо. Значит условия пока цикл
  продолжаеться будет current меньше или равно <= number. По сути в этом цикле current являеться счетчиком. Он считает количество повторений нашего цикла. */
  while (current <= number) {
    if (number % current == 0) count += 1;
    current += 1;
  }
  /* Теперь нам осталось проверить насчитали мы два успешних деления ил больше двух и вывести ответ.

  if (count == 2) {
    std::cout << "Это простое число";
  } eles {
    std::cout << "Это не простое число";
  }
}
  Проверим как работает наша програма */


                                                                    Результат

Введите положительное число:
6
Это не простое число

                                                                    Результат
#include <iostream>

int main() {
  std::cout << "Hello World!\n";
}
Введите положительное число:
41
Это простое число

                                                                    Результат

Введите положительное число:
121
Это не простое число

                                                                    Результат

Введите положительное число:
2017
Это простое число

Наша програма работает и вроде бы работает правильно. Но есть один не большой не достаток который сразу не заметен. Давайте попробуем ввести число милиард. Мы видим что наша
програма работает но очень долго. Мы видим чио на числе милиард наша програма работает очень долго.

Здесь мы приходим к понятию эфективности программы. Это число не простое оно делиться уже на два это значит, что уже н второй итерации цикла все становиться ясно. Но наша
програмаделает милиард итераций этого цикла то есть вот эти команды

while (current <= number) {
    if (number % current == 0) count += 1;
    current += 1;

Она повторяет милиард раз подряд имено поэтому занемат столько времени.

Гигагерцы - это параметр скорости "соображалки" процессора. Чем больше этих гигагерц, тем быстрее думает комп.

Один гигагерц озночает что процесор может выполнить примерно милиард простых операций в секунду. Но в нащем цикле было несколько операций поэтому выполнения милиарды операций
токого цикла занемало около 10 секунд. Полезно держать в голове тьакое предстовления один милиард повторения простого цикла как раз занимает премерно несколько секунд. Это
значит, что:

                                            ОРИЕНТИРОВОЧНОЕ ВРЕМЯ ВЫПОЛНЕНИЯ программы

        Количество операций

        1 000 000                               малая доля секунды
        100 000 000                             около секунды
        1 000 000 000                           несколько секунды
        1 000 000 000 000                       неколько часов

Пока мы не имели дело с цикломи мы были не в состоянии нписать такую программу которая заставила бы компьютер задуматься на долго. Но с помошью циклов очень легко нагрузить
процесор на бесполезными вычислениями и застовляя повторять одно и тоже милиарды десятки милиардов раз.
Иногда токое даже может быть нужно, но в большенстве случаях програмисты все таки стараються сделать свои програмы более эфективными. То есть получать результат с меньше
количством вычислений.


                                                        break


Поэтом сейчас мы впервые займемся оптимизацией нашей программы. То есть вснесем такие испровления что бы она достигала того же результата быстрее. Как мы уже говорил с
случием числом милиард ответ становиться понятен уже на второй шаге наше число поделилось на два без остатка, а значит оно точно непростое нет смысло проверять остолные
варианты. Поэтому мы хотели бы написать следушие команду.

Если if после проверки на делимость обноружим, что count уже равен двум то нужно сразу же выйти из цикла, а непродолжать выполнчть его дальше. Для этоого сушествует
специальная команда breek с перевода с англиского это можно перевести как прервать.

if (count == 2) break;

Конечно в даном случае имееться ввиду прервать цикл. Давайте еще раз подумаем как это будет работать.



Мы проверяем одно число за другим

  while (current <= number) {
    if (number % current == 0) count += 1;

и если исходное число делиться на текушие то добовляем единицу к результату нашего подсчета.
 
 current += 1;

Но если мырбноружим, что мы уже насчитали два делителя то мы сразу же выходим из цикла

if (count == 2) break;

и вот эта команда игнорируеться.

current += 1;

Как видите Replit подсвечивает слово breek такимже цветом как и слова if, while, int - это еще одно зарезервированое слова языка С++ и таким именим тоже нельзя назвать
переменую. Давайте запустим и проверим как работает наша программа и сново введем чсло милиард.



#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;
  
  int current = 1;
  int count = 0;

  while (current <= number) {
    if (number % current == 0) count += 1;
    if (count == 2) break;
    current += 1;
  }
  
  if (count == 2) {
    std::cout << "Это простое число";
  } else {
    std::cout << "Это не простое число";
  }
}


                                                                    Результат

Введите положительное число:
1000000
Это простое число

И получаем ответ на этот раз быстро и он не роавильный. Дело в том, что после такой правки count будет равно двум после выхода из цикла в любом случае даже если чесло было не
простое. Поэтому нам нужно изиенить условие ввывода ответа.#include <iostream>

int main() {
  std::cout << "Hello World!\n";
}
Каким должно быть новое условие? Давйте подумаем. Если чсло было не простым то мы выйдим из цикла прежде времено и  current не успеет стать равно number. Но если число было
простым то current санет равно number и только в этот момент мы выйдим из цикла.

Позтому правильное условие будет выглидеть так:

если current столо равно number после выхода из цикла то число было простым, а инче нет.

Давайте сново проверим


#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;
  
  int current = 1;
  int count = 0;

  while (current <= number) {
    if (number % current == 0) count += 1;
    if (count > 2) break;
    current += 1;
  }
  
  if (count == number) {
    std::cout << "Это простое число";
  } else {
    std::cout << "Это не простое число";
  }
}

                                                                    Результат

Введите положительное число:
1000000
Это не простое число

Как видим теперь после нашей правки ответ для числа милиард мы получили почти мгоновено. Команда break работает только внутри цикла если бы мы попытались написать break
снаруже цикла то нас бы не понялли и мы бы получили ошибку

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;
  
  int current = 1;
  int count = 0;

  while (current <= number) {
    if (number % current == 0) count += 1;
    if (count > 2) break;
    current += 1;
  }
  break;
  if (count == number) {
    std::cout << "Это простое число";
  } else {
    std::cout << "Это не простое число";
  }
}

                                                                    Результат

при запуски прграмы нет цикла поэтому нечего прерывать.

./main.cpp:16:3: error: 'break' statement not in loop or switch statement
  break;
  ^
1 error generated.
make: *** [Makefile:10: main] Error 1



Кроме того break даже внутри цикла используеться только внутри условной конструкции

 if (count > 2) break;

 Если бы мы пытались написали break просто так не под условием то это озночало бы что это команда ( break ) выполниться в любом случае,
 
   while (current <= number) {
    if (number % current == 0) count += 1;
    if (count > 2) break;
    current += 1;
  }
  break;
 а значит цикл не выполниться целиком не одгого раза команды которые находиться между  break и закрываюшей фигурной скобки вобше будут всегда проигнорированы.

Но мы заметили, что можно нащу программу гораздо локоничней.

Дело вот в чем в обще нету смысла проверять цифры одини number исходное число всегда будет делиться на них поэтому исходную проверку можно начинать саразу с числа два,

int current = 2;

а прекращять ее на один шаг ранше уже тогда когда current станет равно number делать е чего не нужно и теперь переменая count вообше не нужна. Потому что если мы хоть раз
обноружим, что number делиться на current можго сразу выходить из цикла, а вот эти троки можно просто удолить.
                                        Логические оператрпы
  std::cout << "Введите положительное число:\n";
  std::cin >> number;
  
  int current = 1;
  while (current < number) {
    if (number % current == 0) break;
    current += 1;
  }
  
  if ( current == number) {
    std::cout << "Это простое число";
  } else {
    std::cout << "Это не простое число";
  }
}

Давайти запустим и проверим что все работает:



                                                                    Результат

Введите положительное число:
6
Это не простое число

                                                                    Результат

Введите положительное число:
2017
Это не простое число

Как видим первое написаное нами решения вновь оказалось избыточно длиным и усложненым. С опытом приходит умения видить менее короткие и локоничные решения.

Давайти попробуем ввести в нашу програму не один милиард, а три милиада. По идее мы должны бы увидить моментальное решения и получить ответ (Это не простое число), но что то
пошло не так давайте подождем и ждем долго. И в незапно мы получили ответ (Это простое число) но в чем же дело. В нашей программе есть ошибка? На самом деле нет просто до
сих пор мы некогда не работали такими большими числрми и поэтому такой проблемы не когда не случалось. Когда мы только начинали изучать переменые мы сказали, что в
переменой типа int можно хранит почти любое целое число. Пришло время уточнить что зщначит это почти.

Как мы уже говорили под каждую переменую в компютире выделяеться некоторое оличество памяти. Компютерная память не формально говоря состоит из ячеек. Любая переменая типа
int занемает всего одно и тоже количество ячеек памяти и в этих ячейках можно хранить лиж число из огрониченого диапозона.
Подобно тому как в четрех тетрадных клеточках мы не можем записать слишком длиное число так и в переменую типа int под которую выделено четыре байта мы е можем сохронить
число больше чем некоторое значение. 

                                  ГРАНИЦЫ ДОПУСТИМЫХ ЗНАЧЕНИЙ int

МАКСИМАЛОЬНОЕ допустимое значение  - 2 147 483 647

МИНИМАЛЬНОЕ допустимое значение    -  -2 147 483 647

Позже мы вернемся к этой теме и обсудим почему это число имено такое, а также как всетаки хранить числа большего размера. А пока надо запомнить что ельзя записать в 
еременуютипа int число больше чем это в противном случае повидения нашей програмы будет не предсказуемо.

Ну и на последок давайти сделаем еще одно маленькое упрошение. Как мы успели заметить, что при работе с циклом нам доваольно часто приходиться такую операцию как прибовления
еденицы к некоторой переменой

  current += 1;;

 поэтому для такой операции придумали специальное название и обозначение вместо того чтобы писать  current += 1; можно писать

 ++ current;

 Этоо операция называеться ИКРИМЕНТ действие этой команды действие и этой строчки current += 1 и перемена  current  просто увеличиться на еденицу


                                        Тип bool

Прежде чем приступить к новому уроку. Давайте разберем пример

                                                                ЗАДАЧА - 5       (По даному числу вывести число записаны теми же цифроми в обратном порядке)

/* Чтобы это сделать давайте откроем код программы котороя подсчитывала сумму цифр числа. И исправим его так что бы эта программа решала нужную нам задачу.
Для этого мы удолим все что связано с переменой sum потомучто она нам не нужна. */

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;
  
  // int sum = 0;  -  удолили
  while (number != 0) {
    /* sum += number % 10;  -  удолили
       И подумаем что делать в сыкле вместо этого пусть нам ввели число 321 как бы мы могли ввывести цифры этого числа в обратном порядке. По идеи в этом случае мы должны вывести пользевателю число 123. Но можно применить такой номер. Вместо того чтлбы выводить это число целиком. Можно просто ввыводить цифры одну за другой без пробелов. Тогда пользевателю будет казаться будто мы ввывели одно число состояших из этих цифр.
       
       Это значит что на очеридной итерации цикла нам нужно просто вывести очеридную цифру этого числа. И это цифра как мы уже знаем полуаеться взятием остатка от деления даного числа на 10*/
    std::cout << number % 10;
    number /= 10;
  }
   /* std::cout << "Сумма цифр в числе равна: " << sum;    -    удоили 
   Запустим и проверим как это работает*/
}

                                                                    Результат

Введите положительное число без нулей в начале:
321
123

                                                                    Результат

Введите положительное число без нулей в начале:
2007
7002

Мы решили даную задачу но немного схитрили. Мы так и не получил из исходного числа нужное нам число мы просто откусывали цифры по одной и ввыводили их друг за другом. Но
как же всетаки получить нужное нам число внутри самой программы. Насамом деле потребуеться совсем маленьких изменений. Так же как мы можем откусывать от числа по одной
цифры  помощью оператора деления мы можем и приписывать к числу цифру справа используя уможения и сложения.

                                                                    Например:

Если бы мы хотели к числу 123 припесат с права 4 то это было бы все ровно что уможить на 10 и прибавить 4.

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число без нулей в начале:\n";
  std::cin >> number;

  /* Давайте заведем переменую result котрая изначально равна нюлю, а при каждой итерации цикла мы будем приписывать к ней справа очередную цифру. */
  int result = 0;
  while (number != 0) {
    /* тоесть  result мы будем заменять на result умноженая на 10 плюс очередная цифра number % 10 */
    result = result * 10 + number % 10;
    number /= 10;
  }

  // и вот этот ввывод нам уже не нужен
  /*  std::cout << number % 10;
    number /= 10;
  } */
  
  // И в конце нам нужно просто вывести result
  std::cout << result;
}

// Запустим и посммотрим как это работает

                                                                    Результат

Введите положительное число без нулей в начале:
123
321

                                                                    Результат

Введите положительное число без нулей в начале:
2007
7002

У любой переменой есть свой тип который не меняеться в течении работы программы. Мы уже изучили два типа

int - для хранения целых чисел
string  - для хранения строг

На самом деле тип определить не толко для переменых но и для любого вырожения. Тип выражения это тип того значения которое получиться если вычтить это вырожения.

Например:

вырожения 2 + 2 имеет тип int
потомучто оно равно 4, а это значения типа int
Точно также тип int имеет вырожения составленых из целых чисел и операторов вычитаний, сложений, умножений, делений, взятия остатка в любых комбинациях. Чтобы сохронить
зачения вырожений в какойто переменой нужно что бы переменая имела такой же тип как это вырожения.

Но какой тип имеет вырожения с операторами сравнения
Например. Если у нас есть условия 2 меньше 3 то можно ли сохронить в какой небудь переменой результот такого сравнения. Разумееться можно и сейчас мы разучим новый тип 
данных преднозначены какрась для этого.

Результатом сравнения могут быть всего два значения истина или ложь. Тип данных в котором можно хранить эти значения по русски называються логические но чоще используеться
англиское название bool (булевский) тип даных

Слово bool (булевский) оброзовано от английский математик и логик Джорджа Буля. Переменая булевского типа может хронить только два значения истина или ложь больше в нее
нечего записать нельзя.

Для объявления переменой булевского типа используеться ключевое слово bool например можно записать так


                                        Тип bool

                                        ЛОГИЧНСКИЙ ОПЕРАТОР ТИП (bool)

          bool b = 2 < 3; ИСТИНА true

          bool b = 2 > 3; ЛОЖЬ   false

Теперь мы можем по другому взглянуть на конструкцию if и while.

Когда мы начинали изучать условия. Мы говорили, что условие у нас будет только матиматические вырожения но вобше может быть кое что другое. Теперь мы можем сказать более
точно. Условие может быть любое вырожения который имеет тип bool.

#include <iostream>

int main() {
  bool b = 2 < 3;
  /* Разумееться переменая типа bool  имеет тип bool. Поэтомумы можем использовать ее саму в качестве условия*/
  if (b) {
    std::cout << "Условие сработало!!!";
  }
}

// Запустим и проверим что условие работало

                                                                    Результат

Условие сработало!!!

В этом примере мы задали началное значение переменой b как результат вычисления вырожения 2 < 3. Тоесть программа сравнила 2 и 3 получило результат истина м записала его
в переменую.

Но сушествует способ задать значения истина и ложь непосредствено. 

#include <iostream>

int main() {
  bool b = 2 < 3;

  // Для обозначения ИСТИНА сушесвует ключевое слово true
  bool t = true;

  // Для обозначения ЛОЖЬ сушесвует ключевое слово false
  bool f = false;

  // Давайте проверим что если мы подставим  условия (if) переменую (f) которая равна false условия не сработает
  if (f) {
    std::cout << "Условие сработало!!!";
  }
}

// Запустим и проверим что условие не сработало. Сообшение не вывелось

                                                                    Результат

./main.cpp:9:8: error: unused variable 't' [-Werror,-Wunused-variable]
  bool t = true;
       ^
./main.cpp:6:8: error: unused variable 'b' [-Werror,-Wunused-variable]
  bool b = 2 < 3;
       ^
2 errors generated.
make: *** [Makefile:10: main] Error 1


Сами по сибе слова false и true разумееться тоже имеют тип bool и тоже могут быть использованы в качестве условий например вот так можно создать бесконечный цикл

#include <iostream>

int main() {
  bool b = 2 < 3;
  if (b) {
    std::cout << "Условие сработало!!!";
  }
  while (true) {
      std::cout << "Это текст будет выводиться бесконечно!!!";
  }
}

// Запустим и проверим что текст будет выводиться бесконечно


                                                                    Результат

Это текст будет выводиться бесконечно!!!Это текст будет выводиться бесконечно!!!Этекст будет выводиться бесконечно!!!Это текст будет выводиться бесконечно!!!Это текст будет
выводиться бесконечно!!!Это текст будет выводиться бесконечно!!!Это текст будет выводия бесконечно!!!Это текст будет выводиться бесконечно!!!Это текст будет выводиться
бесконо!!!Это текст будет выводиться бесконечно!!!Это текст будет выводиться бесконечно!!!Этекст будет выводиться бесконечно!!!Это текст будет выводиться бесконечно!!!
Это текст бу выводиться бесконечно!!!Это текст будет выводиться бесконечно!!!Это текст будет выводия бесконечно!


                                        Логические оператрпы

Теперь вспомним о логических операторах мы знаем три таких && - И ()Конъю́нкция, || - или (дизъюнкция), !- не (отрицания). По научному они называються конъю́нкция, дизъюнкция
и отрицания. Теперь мы можем более точно объяснить действия каждого из них.

Оператор И принемает на вход два значения типа bool и на их основе вычесляет новое значения типа bool по следушему правилу если оба значения были true то результатом будет
true, а иначе false. Например если мы напише так:

bool = true && false  - то результатом b будет fals по скольку одна из частей была fals.

Давайте проверим что условие не срабтает если мы поставим в него b

#include <iostream>

int main() {
  bool b = true && false;
  if (b){
    std::cout << "Условие выполнено";
  }
}

                                                                    Результат


Видим что условие не сработало

Ну а оператор ИЛИ || тоже принемает на вход два значения типа bool но результатом являеться true если хотя бы одно из исходных значений было true.

Попробуем написать так и запустим

#include <iostream>

int main() {
  bool b = 2 < 3 || false;
  if (b) {#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;

  /* Первоя приходящия в голову идея это подсчитать на какое количество чисел наше исло делиться без остатков. Если наше число простое то таких должно насчитаться ровно два
  наш число и единиться. Как это напиать? Допустим мы хотим проверить число 42 и подсчитать сколько будет делителей без остатка. Сначало проверим делиться ли оно на еденицу
  да делиться, потом проверяем на 2 да опять делиться.
  
  Поэтому нам потребуеться еше две переменые. Первую переменую мы назавем current. Она будет постепено меняться от одного до number и на нее мы будем каждый раз пытаться
  делить. current означает текуший, что ознчаем смысл этой переменой в ней будет записан текуший кандидат которого мы проверяем. */

  int current = 1;

  /* И кроме того нам еще понадобиться переменая count. В ней мы будим считать сколько кондидато было успешных, то есть сколько раз наше число поделилось на current без
  остатка. Изначадьно оно равно нулю тотому что мы еще не чего не проверили или не поделили */
  int count = 0;

  /* Теперь надо написать цикл
  while () {
                                              Что мы будем делать в цикле мы будем проверять делиться ли number на очередное число тоесть на current
    if (number % current == 0) count += 1;    и если делиться то увеличивать count на еденицу

    после этого мы должны увеличит current на еденицу
    current += 1;                             мы должны увеличит current на еденицу что бы на следушей итерации цикла проверять уже другого кандидата
                                              что должно быть условием цикла while () до каких пор мы должны все это дело повторять.
                                              
  Очевидно до тех пор пока наш кандедат current не станет болше чем исходное число number Если current больше number то болше повторять циклне надо. Значит условия пока цикл
  продолжаеться будет current меньше или равно <= number. По сути в этом цикле current являеться счетчиком. Он считает количество повторений нашего цикла. */
  while (current <= number) {
    if (number % current == 0) count += 1;
    current += 1;
  }
  /* Теперь нам осталось проверить насчитали мы два успешних деления ил больше двух и вывести ответ.

  if (count == 2) {
    std::cout << "Это простое число";
  } eles {
    std::cout << "Это не простое число";
  }
}
  Проверим как работает наша програма */
#include <iostream>

int main() {
  std::cout << "Hello World!\n";
}
  if (count == 2) {
    std::cout << "Это простое число";
  } else {
    std::cout << "Это не простое число";
  }
}
    std::cout << "Условие выполнено";
  }
}

                                                                    Результат

Условие выполнено

Мы видим что условия срботало поомучто одна из частей была true (2 < 3). два меньше трех это истина.

Но и наконец операция отрицание ! просто занемает true на false и наоюорот. Давайте проверим:

#include <iostream>

int main() {
  bool b = false;

  //  а условия поставим отрицание b
  if (!b) {   
    std::cout << "Условие выполнено";
  }
}

                                                                    Результат

Условие выполнено

Тип даных bool важен и сам по сибе но кроме всего прочего с его помши можно зачастую упростить решения тех задач где нам приходилось использывать break.

Давайте вернемся еше раз к задачи проверки числа на простату

                                                                ЗАДАЧА - 6       (Дано положительно целое число и надо проверить являеться оно простым числом (при помоши
                                                                                оператора bool (строка 731)))

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;

  int current = 2;

  while (current < number) {
    if (number % current == 0) break;    
    ++current;                             
  }                                            

  if (current == number)  {
    std::cout << "Это простое число";
  }   else {
    std::cout << "Это не простое число";
  }
}


/* Посмотрим на код  котором мы в итоге написали. Эту програму как не страно все еще можно улучшить. Дело в том что она сейчас трудна для пониминия. Если сейчас сохроню, а
потом спустя месяц сново на него посмотрю. То мне придеться вдуматься что бы понять почему условия простоты числа имено такое ((current == number)).
После окончания цикла переменая current уже не несет смысла потому что она обозночало текушего кандедатав цикле на проверки на делимость. А осле цикла она может обозночать
либо последнего провереного кандедата либо следушего за ним которого мы неуспели проверить потомучто циклзакончился. И что бы понять что дает нам сравнения current и number
после окончания цикла нужно сново вчитываться в логику работы цикла. С первого взгляда на этот условия совершено неясно почему равенство current и number озночает простоту
числа.

Все станет гораздо легче чтаться если применить булевскую переменую.  */

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;

  int current = 2;

  // Давайте заведем эту переменую перед циклом и назовем ее found. Почему found по смыслу. found озночает нашли и faund равен true будет озночать что делитель найден
  bool faund = false;    //  Изначально мы ешене нашли ни кокого делителя зададим found равен false.

  /* Теперь исправим наш цикл нам нет смысла продолжать его выполнять если какойто делитель уже найден. Поэтому продолжать его стоит только если 
  current меньше number и не !faund пока не нашли продолжаем искать. Теперь если  faund стало равно true то мы выйдем из цикла на ближашей итерации, а значит нам уже не
  потребуеться команда break */
  while (current < number && !faund) {

    /* Теперь если  faund стало равно true то мы выйдем из цикла на ближашей итерации, а значит нам уже не потребуеться команда break.Что теперь на нужно делать в цикле
    вместо break? Понятно если мы нашли делитель то нужно присвоить faund равно true. Мы могли бы записать это вот так 
    if (number % current == 0) break; 
    
    Мы могли бы записать это вот так  
    if (number % current == 0) faund = true; Дело в том что вырожения остаток от деления number current равен нулю уже имеет тип bool и нам не надо использывать комаду if
    мы можем сразу прсвоить значение этого вырожения переменной faund 

    Если оно было true то это будет озночать, что делитель найден а если нет то нет  */

    faund = number % current == 0;    /* На первых порах такие вырожения могут удевлять но к ним стоит привыкнуть здесь все обсолютно каректно мы присваеваем булевской
    переменой результат сравнения. Сначало выполняеться взятия остатка отделения number % current потом сравнения = и впоследию очередь присваивание == 0;*/
    ++current;                             
  } 
  
  // Теперь условия которое нужно проверить после цикла формулируеться интуактивно - очевидно если мы не нашли делитель то число простое,
  if (faund)  {
    std::cout << "Это простое число";

  // а иначе непростое
  }   else {    
    std::cout << "Это не простое число";
  }
}

// Давайте запустим и проверим.

                                                                    Результат

Введите положительное число:
6
Это простое число

                                                                    Результат

Введите положительное число:
11
Это не простое число


Ну и последние улучшения мы уже оптимизировали нашу програму так, что если число не простое то она давольно быстро это обноруживает. Только вот если число простое ей
все ровно придеться перебрть все числа вплоть до него. Например ели мы возмем 1000000007, а оно простое мы опять зависним на несколько секунд.

Сейчас мы сделаем нашу програму еше эфективней так что даже в этом случае она будет работать быстро. Оказываеться нам в любом случае не надо проверять все числа вплоть до 
number.

Давайте разберем это на примери числа 48. Если мы начне проверять на какие оно делиться то мы увидем что вот это все возможные варианты

                                              48
                                              2  24
                                              3 * 16
                                              4 * 12
                                              6 * 8   и после этого мы замечаем что числа начинают повторяться.



                                              а * b

                                                      Отсюда можно понять что проверять делители можно только до серидины, что во второй половине наших проверок мы не чего
                                                      нового не найдем. Но что такое середина если мы преставили число 48 в видепроизвидения аких то двух чисел то серидина
                                                      в нашем понимании будит тогда когда эти числа равны. Но если они равны то это значит каждый из них равен квадратному
                                                      корню из 48. Вот это и будет серидина когда
                                              а       станен болше чем квадратный корень из 48
                                              b       станет меньше чем квадратный корень из 48

                                                                        И ВСЕ ТАКИЕ ПРОИЗВЕДЕНИЯ НЕ ДАДУТ НАМ НОВОЙ ИНФОРМАЦИИ

                                              8 * 6
                                              12 * 4
                                              16 * 3
                                              24 * 2

Поэтому нам достаточно прерватьцикл тогда когда current станет боьше квадратному корню из number, а это все равно что current в квадрате тоесть current * current станет
больше чем number значит условия продолжения это то что current * current меньнше или рано number

#include <iostream>

int main() {
  int number;
  std::cout << "Введите положительное число:\n";
  std::cin >> number;
  int current = 2;
  bool faund = false;

  /* Поэтому нам достаточно прерватьцикл тогда когда current станет боьше квадратному корню из number, а это все равно что current в квадрате тоесть current * current станет
     больше чем number значит условия продолжения это то что current * currentif (faund) меньнше или рано number. */   
  while (current * current <= number && !faund) {
    faund = number % current == 0;    
    ++current;                             
  } 
  if (!faund)  {
    std::cout << "Это простое число";
  }   else {    
    std::cout << "Это не простое число";
  }
}

// Давайте сново запустим и проверим.

                                                                    Результат

Введите положительное число:
1000000007
Это не простое число

if (faund)
А теперь обротите внимани что для этого испровления нам пришлось изменить всего одну строчку

while (current * current <= number && !faund)

так бы не получиось сделать если бы мы использовали не понятое условия current = number в этом мести if (!faund). Такие булевские переменые что бы прерывать цикл програмисты
называют флажками

Разберем еше пару задач.

                                                                 ЗАДАЧА - 7       (Проверить прадо ли что введеное число состоит только из едениц и нулей.)


/* Его можно было бы решить двумя способами. Старым способок при помоши break и новым с помошью булевской переменой. Разбереп оба эти способа.

                                                                          Способ первый при помоши break


#include <iostream>

int main() {
  int number;
  std::cout << "Введите число \n";
  std::cin >> number;

  /* Заведем переменую lastDigit в которую будем сохронять последнию цифру числа пусть из начально она равна нулю */
  int lastDigit = 0;
  while (number != 0) {

  /* Накаждой итерации цикла мы будем заменять значения переменой lastDigit на значения очередной цифры. И наша идея заключаеться в следушим. Если мы увидим что в какойто момент эта цифра стала не равна нулю или единицы мы выдим из цикла с помошью break. */
    lastDigit = number % 10;

    /* Если мы увидим что в какойто момент эта цифра стала не равна нулю или единицы мы выдим из цикла с помошью break. */
    if (lastDigit > 1) break;
    number /= 10;
  }
    /* Теперь после того как цикл закончился мы можем проверить чему равна lastDigit. Если бы мы встретили lastDigit больше единицы то сразу вышли бы из цыкла. Поэтому что бы проверить была ли цифра бльше еденицы достаточно посмотреть чему стало равна lastDigit после цикла.
    Если бльше еденицы то ответ на исходный вопрос нет не только из нулей и единицы. */
  if (lastDigit > 1) {
    std::cout << " Нет не только из нулей и едениц ";

    //  А если не больши еденицы
  } else {
    std::cout << " Состоит  только из нулей и едениц ";
  }
}

// Давайте сново запустим и проверим.

                                                                    Результат

Введите число 
126
 Нет не только из нулей и едениц 

                                                                    Результат

Введите число 
0101
 Состоит  только из нулей и едениц 

 Но тоже самое можно было бы сделать не используя break, а используя булевский фложок.

/*                                                              Способ первый булевский фложок */


#include <iostream>

int main() {
  int number;
  std::cout << "Введите число \n";
  std::cin >> number;
  // int lastDigit = 0;
  /* Сново заведем еременую faun которая будет оказывать нашли мы плохую цифру в числе или нет тоесть такую которая больше иденицы из начально она будет рвна fols потому что мы 
    еще не чего не нашли. */
  bool found = false;
  // while (number != 0) {
  // lastDigit = number % 10;
  /* Теперь место того что бы делать break 
  if (lastDigit > 1) break;.*/
  // и надо исправить условия цикла while (number != 0) Теперь продолжать нам имеет смысл только пока faund это fals. И Переменая lastDigit нам теперь сново не нужна. ПОтомучто      мыможем вместо значения этой переменой просто подставлять нужное нам вырожения
  while (number != 0 && !found) {
  // Мы будим заменять значения переменой faund на результат этого сравнения. 
    found = number % 10 > 1; 
    number /= 10;
  }
  /* Условия после цикла тоже переаисываеться
  if (lastDigit > 1) */ 
  if (found) {
    std::cout << " Нет не только из нулей и едениц ";

  //  А если не больши еденицы
  } else {
    std::cout << " Состоит  только из нулей и едениц ";
  }
}
}
// Давайте сново запустим и проверим.

                                                                    Результат

Введите число 
126
 Нет не только из нулей и едениц 

                                                                    Результат

Введите число 
0101
 Состоит  только из нулей и едениц 


На частую используя кострукцию  break можно заменить на использования  булевского фложока и наоборот. Некоторые програмисты считают что break лучше вообше не использывать
так как он затрудняет читаемость программы как мы видели это в предыдушем примере. Но бывает и ситуации когда использывание break удобно и оправдовано например если условия
окончания цикла заранее не известно то его иногда делают бесконечным, а выходят из него с помощью break. В любом случае стоит знать оба способа, а выберать из них в каждом
конкретно случае тот который делает решения вашей задачи проше и понятней.