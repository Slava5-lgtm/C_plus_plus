Урок 5.                                 Логические операторы и сложные условия

                                                        Разбор ДЗ прошлого урока
                                                                ЗАДАЧА -1       (Напишите программу, которая проверяет, делится ли одно число на другое без остатка.) 

#include <iostream>

int main() {
  int a;
  int b;
  std::cout << " Введите два числа:\n";
  std::cin >> a >> b; // Вот так можно вводить два числа в одной строке

  if (a / b * b == a) {
    std::cout << " Да делиться без остатка";
  } else {
    std::cout << " Нет не делиться без остатка";
  }
}

                                                                    Резултат

Введите два числа:
15 3
Да делиться без остатка

                                                                    Резултат

Введите два числа:
16 3
Нет не делиться без остатка

Тоже самая можно было написать кароче использовая ОПЕРАТОР %

#include <iostream>

int main() {
  int a;
  int b;
  std::cout << "Введите два числа:\n";
  std::cin >> a >> b; // Вот так можно вводить два числа в одной строке

  if (a % b == 0) {
    std::cout << "Да делиться без остатка";
  } else {
    std::cout << "Нет не делиться без остатка";
  }
}

                                                                    Резултат

Введите два числа:
15 3
Да делиться без остатка

                                                                    Резултат

Введите два числа:
16 3
Нет не делиться без остатка

                                                                ЗАДАЧА -2        (Вычисляющую сумму налога по прогрессивной шкале в зависимости от полученного заработка:
                                                                                  13% — на доход до 10 000, 20% — на доход от 10 000 до 50 000, 30% — на доход выше
                                                                                  50 000. Однако во многих странах, использующих такую шкалу, эта сумма вычисляется
                                                                                  более сложным способом: налоговая ставка 30% на доход выше 50 000 означает, что 30%
                                                                                  уплачивается не со всей суммы, а лишь с той её части, которая превосходит 50 000.
                                                                                  Аналогично: ставка 20% на доход от 10 000 до 50 000 обязывает уплатить 20% лишь с той
                                                                                  части суммы, которая превосходит 10 000, но не превосходит 50 000. Так, например, с
                                                                                  дохода 100 000 придётся заплатить такой налог:
                                                                                  30% * (100 000 – 50 000) + 20% * (50 000 – 10 000) + 13% * 10 000 = 15 000 + 8000 +
                                                                                  + 1300 = 24 300. С дохода 30 000: 20% * (30 000 – 10 000) + 13% * 10 000 = 4000 +
                                                                                  + 1300 = 5300. Напишите программу, которая спрашивает у пользователя его доход и
                                                                                  рассчитывает сумму налога для него по вышеописанным правилам.)

#include <iostream>

int main() {
  int profit;
  std::cout << "Введите размер прибыли: ";
  std::cin >> profit;
  
  // завели переменую tax для сохронения суммы налоа до начало проверки всех условий и будем формировать эту сумму по частям
  int tax = 0;
  // снаало проверяем
  // если доходбыл свыше 50000 то спишим с той его части превышает 50000 нужную сумму налога и прибавим ее к tax
  if (profit > 50000) {
  // то к налогу прибавим вот такое число (30% * (profit - 50000)) 
    tax += (profit - 50000) * 30 / 100;
  // обрати внимания если бы мы получили 70000 то этот налог подсичвлся бы толкько с 20000 то есть с той части суммы которая превосходит 50000. Для 20000 из 70000 налог
  // мы уже подчитали, теперь нужно подчитать налог для 50000. Поэтому будим считать что, 50000 у нс и осталось и присваеваем к переменой profit = 50000
    profit = 50000;
  }
  // теперь спишим налог с той оставшейся части дохода которые выходила за пределы 10000
  if (profit > 10000) {
  // мы обработали всю часть дохода
    tax += (profit - 10000) * 20 / 100;
    profit = 10000;
  }
// осталось добавить к сумме налога ту часть каторая получаеться из оставшейся суммы 10000
  tax += profit * 13 / 100;

  std::cout << "Размер налога равен: " << tax << "\n";
}

                                                                    Резултат

Введите размер прибыли: 100000
Размер налога равен: 24300

                                                                    Резултат

Введите размер прибыли: 30000
Размер налога равен: 5300


                                                        Вложенные конструкции if

Внутри блоки if может быть любой код в том числе там может быть еще один блок у словием if. Такие конструкции когда один условный блок внутри другого мы будим называть
вложеные условия разбереи пример:

                                                                ЗАДАЧА -3        (Пусть пользрватель вводит два числа, а мы хитим найти максимальное из них)


#include <iostream>

int main() {
  int a;
  int b;
  std::cout << "Введите два числа:\n";
  std::cin >> a >> b;

  if (a > b) {
    std::cout << "Максимальное число: " << a << "\n";
  } else{
    std::cout << "Максимальное число: " << b << "\n";
  }
}

                                                                    Резултат

Введите два числа:
12 15
Максимальное число: 15

                                                                    Резултат

Введите два числа:
15 12
Максимальное число: 15

Теперь предположим что пользователь вводит три числа, а мы по попрежниму хитим найти максимальное из них. Довольно легко понять, что одним сравнением тут не обойтись 

#include <iostream>

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите три числа:\n";
  std::cin >> a >> b >> c;

  if (a > b) {
    if (a > c){ 
    std::cout << "Максимальное число равно: " << a;
  } else {
    std::cout << "Максимальное число равно: " << c;
  }

  } else {
    if (b > c) {
      std::cout << "Максимальное число равно: " << b;
    } else {
      std::cout << "Максимальное число равно: " << c;
    }
  } 
}

                                                                    Резултат

Введите три числа:
1 2 3
Максимальное число равно: 3

                                                                    Резултат
Введите три числа:
1 3 2
Максимальное число равно: 3

                                                                    Резултат
Введите три числа:
3 1 2
Максимальное число равно: 3


                                                        Логические операторы и сложные условия (И ИЛИ)

Мы писали програму которая при веденых трех чисел находила самое большое.

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите три числа:\n";
  std::cin >> a >> b >> c;

  if (a > b) {
    if (a > c){ 
    std::cout << "Максимальное число равно: " << a;
  } else {
    std::cout << "Максимальное число равно: " << c;
  }

  } else {
    if (b > c) {
      std::cout << "Максимальное число равно: " << b;
    } else {
      std::cout << "Максимальное число равно: " << c;
    }
  } 
}

Когда много блока кода вложено друг в друга такой код сложно читать. Хорошим стилем считаеться не создовать вложеный блок если можно обойтись без него.

Мы упрости нашу програму так что бы не было вложеных блоков кода. И сделаем мы это при помощи сложных условий. Мы учитываем несколько факторов когда принимаем решения.
Обычно при формюлировки таких правил для себя мы использум слова И ИЛИ. Когда мы соединяем два простых условия союзом И - это означает что мы требуем одновременог
выполнения их обоих, когда соединяем союзом ИЛИ - это значит что нам достаточно ваполнения хотя бы одного из них. В языке С++ для их обозночения есть специальные
обозначения.

                                                                ЛОГИЧЕСКИЕ ОПЕРАТОРЫ

                                                                &&  - И
                                                                ||  - или

Мы можем состовлять условия вот они:

if (a > 3 && b != 5)  - (а) больше трех и (b) не равно пяти. Если хоть одно из двух частей (((a > 3) - первая часть) ((b != 5) - вторая часть)) условий не выполнено то
условия в целом будет считатья невыполнено

А если мы напишим так:

if (a > 3 || b != 5)  -   то это будет означать что условия будет выполнено когда (а больше трех) или (b не равно пяти). Но есле (а больше трех), а (b не равно пяти)
то условия будет считаться не выполнено

В математике операция И называеться - Конъюнкция (Конъюнкция — логическая операция, ставящая в соответствие каждым двум высказываниям новое высказывание, являющееся
                                                  истинным тогда и только тогда, когда оба исходных высказывания истинны. Для записи конъюнкции используются следующие
                                                  знаки: ∧, •, И, &. Например: А ∧ В, А • В, а и в, А & Б.).

А операция || называеться           - Дизъюнкция (Дизъюнкция — это логическая операция, которая объединяет два высказывания и возвращает значение истины, если хотя бы
                                                  одно из этих высказываний истинно. То есть в логике мы эти высказывания складываем, чтобы получить новое высказывание,
                                                  которое будет соответствовать хотя бы одному из поставленных условий или сразу двум.).

Вернермся к задачи про максимумы:



#include <iostream>

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите три числа:\n";
  std::cin >> a >> b >> c;

 // Давайте для примера оставит условия являеться ли (а) максимумом трех чисел
  // если a > d и a > c
  if (a > b && a > c) {
  // то
    std::cout << "Максимальное число равно: " << a;
  // разберем остольные случаи когда максимум b и с
  // пишим иначе (else if) и второе условмя (b > a и b > c)
  } else if (b > a && b > c) {
    std::cout << "Максимальное число равно: " << b;
  // и также пишем третие условия
  } else if (c > a && c > b) {
    std::cout << "Максимальное число равно: " << c;
  }
}

А эту часть можно удолить

{

  if (a > b) {
    if (a > c){ 
    std::cout << "Максимальное число равно: " << a;
  } else {
    std::cout << "Максимальное число равно: " << c;
  }

  } else {
    if (b > c) {
      std::cout << "Максимальное число равно: " << b;
    } else {
      std::cout << "Максимальное число равно: " << c;
    }
  } 
}

                                                                    Резултат

Введите три числа:
1 2 3
Максимальное число равно: 3

Но при такой комбинации она не работает  (std::cout << "Введите три числа:\n"; 1 1 0):

                                                                    Резултат

Введите три числа:
1 1 0

Значит это програма работает не всегда правильно. Мы упустили случай когдамаксимальное чило одному из оставшихся чисел. Что бы прграмма начала работать правильно и в
этих случаях тоже поменяем все строгии не равенство на нестрогии тоесть заменим все знаки > на знаки >=

#include <iostream>

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите три числа:\n";
  std::cin >> a >> b >> c;

  // если a > d и a > c
  if (a >= b && a >= c) {
  // то
    std::cout << "Максимальное число равно: " << a;
  // разберем остольные случаи когда максимум b и с
  // пишим иначе (else if) и второе условмя (b > a и b > c)
  } else if (b >= a && b >= c) {
    std::cout << "Максимальное число равно: " << b;
  // и также пишем третие условия
  } else if (c >= a && c >= b) {
    std::cout << "Максимальное число равно: " << c;
  }
}


                                                                    Резултат

А тк все хорошо (std::cout << "Введите три числа:\n"; 8 8 5)

Введите три числа:
8 8 5
Максимальное число равно: 8

Но и здесь можно упростить если максимум не  (a) и не (b) то максимум являеться (с). И тогда это можно дополнительно не проверять (строка 334(if (c >= a && c >= b)))
кажеться мы упростили д придела. А вот и нет эту задачу можно было бы решить и без сложных конструкций и без сложных условий.

                                                    Для этого надо было завести еще оду переменую

#include <iostream>

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите три числа:\n";
  std::cin >> a >> b >> c;

  int max =a;
  if (b > max) max = b;
  if (c > max) max = c;

  std::cout << "Максимальное число: " << max;
}

                                                                    Резултат

Введите три числа:
9 9 5
Максимальное число: 9

Кроме операции И и ИЛИ есть и третия логическая операция она называеться ОТРИЦАНИЯ. Отрицания некоторого условия это такое условие которое ЛОЖНО когда исходно условное
истина и наоборот. Например если у нас есть переменая Х. Tо отрицания условия Х > 0 это условия Х < или = 0

Для записи отрицания применяеться !

if (!(x > 0)) это запись обозночает тоже самое if (x <= 0) скобки вокруг икс больше нуля обязательно нужны, что бы трецания относилось ко всей записи (x > 0), а не 
только к (х). Если записать такую запись (!x > 0) без скобок она будет иметь савсем другой смысл


                                                        Упрощение логический уровнений. Приоритеты операторов.

                                                                ЗАДАЧА -5       (Построить треугольник по трем сторонам)

Как известно из трех отрезков можно построить треугольник когда длина любого отрезка меньше суммы двух других отрезков. Чтобы из трех даных отрезков a b c  составить
треугольгик нужно что бы:
a < b + c
b < a + c
c < b + a

                                              ВОТ ТАК ВЫГЛИДИТ КОД

#include <iostream>

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите длины сторон треугольнтка:\n";
  std::cin >> a >> b >> c;
  // Мы проверяем что каждая сторона меньше суммы двух оставшихся
  if (a < b + c && b < a + c && c < a + b) {
    std::cout << "Да";

  } else {
    std::cout << "Нет";
  }
}

Сколько есть совподаюших чисел среди трех даных. Проше всего отбросить случай когда все три числа совпадают. Запишм условия

Если (а) совподает (b) и (b) совпадпет с (с), а третие уже проверять не надо
if (a ==b) && (b == c){
  то ввыводим
  std::cout << "3 совподающих"


Если не все три числа совподают проверим, чио два совпадают. Совппадать могут: первое или второе, второе или третье, или первое и третье. Это нам над записать в
условия применим слово (else) и запишим

  } else if (a == b || b == c || a == c) {)
    std::cout << "2 совподающих";
  

Если не одно из перечисленых условий не выполнелось значит сриди чиселнет совподаюших. Тогда это можно сразу вывести на экран без дополнительных проверок.

  } else {
    std::cout << "Нет совподающих";
  }

include <iostream>

int main() {
  int a;
  int b;
  int c;
  std::cout << "Введите длины сторон треугольнтка:\n";
  std::cin >> a >> b >> c;

  if (a == b && b == c) {
    std::cout << "3 совподающих";

  } else if (a == b || b == c || a == c) {
    
    std::cout << "2 совподающих";
  } else {
    std::cout << "Нет совподающих";
  }
}

                                                                    Резултат

Введите длины сторон треугольнтка:
1 2 1
2 совподающих


                                                                    Резултат
Введите длины сторон треугольнтка:
3 3 3
3 совподающих


                                                                    Резултат

Введите длины сторон треугольнтка:
1 2 3
Нет совподающих


                                                                ЗАДАЧА -6       (С клавиатуре вводят три числа день, месяц и год. Надо проверить дествительно эти числа
                                                                                задают каректную дате)

#include <iostream>

int main() {
  int day;
  int month;
  int year;
  std::cout << "Введите день, месяц и год: ";
  std::cin >> day >> month >> year;

    /* Если нам надо было написать что номер месяца поподает в диапозон от 1 до 12 мы бы написали
    if (month >= 1 && month <= 12) но нам нужно написать отрицания этого условия
    поэтому мы запишим вот так if (!(month >= 1 && month <= 12)), а можно ли записать тоже самое условия но без применения операции отрецания. Что бы выражения выгледило проще.     Что означает что номер месяца поподает в диапозон от 1 до 12. Возможны два варианта он больше 12 и поэтому не поподает или он меньше 1. Поэтуму нам нужно приминит оператор      && (ИЛИ) 
    Когда у нас есть условия состояший из двух частей соединеным союзом И, а мы хотим сформулировать отрицание к нему то нам нужно пользоваться союзим ИЛИ. 
                                            НАПРИМЕР
                                            
    Если я говорю " Неверно что солнышко светит и птички поют - это означает что хотябы одна из частей не выполнено то есть " " солнышко не светит или птички не поют" и наоборт     если нам нкжно своиулировать отрецания содержащий союз ИЛИ, то нужно пользоваться союзом И
    В математики эти два логических закона называються: Закон де Моргана

    Закон де Моргана.– общее название логических законов, связывающих с помощью отрицания конъюнкцию («и») и дизъюнкцию («или»). Названы именем англ. логика XIX в. А. де            Моргана. Один из этих законов можно выразить так: отрицание конъюнкции эквивалентно дизъюнкции отрицаний. Напр.: «Неверно, что завтра будет холодно и завтра будет дождливо,     тогда и только тогда, когда завтра не будет холодно или завтра не будет дождливо».

    В програмировании они часто помогаютзаписвать сложные условия в более прстом виде. Вернемся к задачи мы отбросили лучаи когда номер мсяца был не допустимый */

    // Номер месяца поподает в диапозон от 1 до 12

  if (month < 1 || month > 12) {
    std::cout << "Eroor";

  /* И теперь осталась наиболее трудная часть проверить, что номер дня не привоскодит количеству дней в этом месяце. Написали else,  разберем как написать эту оставшиюся         проврку Прежчем проверить что номер дня находиться в нудном диапозоне. Надо определить граници этого дипрозона для нашего месяца.*/

  } else {

  // Поэтому здесь мы заведем новую переменую и назовем ее int daysInMonth (количество дней в месяце). 
    int daysInMonth;

  // Если месяц один из следущих (январь1,  март3  май5  июль7 август8  октябрь10 дукабрь12)
    if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {

  // тогда 31 день 
      daysInMonth = 31;

  // Если месяц один из следущих (апрель4 июнь6, сентябрь9, ноябрь11)
    } else if (month == 4 || month == 6 || month == 9 || month == 11) {

      //Иначе 30 дней
      daysInMonth = 30;

  /* какой вариант остаеться посколько мы проверили, что month еаходитьс в пределах от 1 до 12 то если эти два условия не выполняются едиственый оставшийся вариант, что это 2 -   февраль. Мы можем это доолнительно не проверть
  Но здесь нужно еще одно условия если год высокосный то в феврале будет 29 дней, а иначе 28. Поэтому нам сейчас нужно проверить являеться год высокосный. По определению          высокосный являеться такой год, номер которого делиться на 400 или делиться на 4 и не делиться на 100. Это можно сразу перевести на язык С++ на прямую. Так и запишим: */

  /* Это можно сразу перевести на язык С++ на прямую. Так и запишим:
  Если год делиться на 400 без остатка или делиться 4 и не делиться на 100 то год высокосный и: */
    } else if (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) {

    // дней в месяце февраль 29
      daysInMonth = 29;
    } else {
    // Иначе год не высокосный и дней в месяце февраль 28
      daysInMonth = 28;
    }

    /* В нутри одного условия  (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) мы использовали обе логические операции (&& - и) (|| - или). На этом месте поподробней        такое условия можно прочитать двумя способами. Сначало выполнить операцию (ИЛИ - ||) если бы скобки стояли вот так ((year % 400 == 0 || year % 4 == 0) && year % 100 != 0),      а потом выполнить операцию (И - &&). Или сначало выполнить (И - &&) если бы скобки стояли вот так (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) а, только потом        (или - ||) результаты могли бы получиться разные
    В С++ есть четкие правила на этот счет сначало виполняеться (И - &&), а потом (ИЛИ - ||). У этого есть матиматическое обоснования. В матиматической логики операция ((И -        &&) - это умножения), а ((ИЛИ - ||) - сложения. Поэтому тот что мы написали бес скобок (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0) будет читаться если бы скобки      стояли (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)) */
    
    // Если номер дня поподает от 1 до daysInMonth
    if (1 <= day && day <= daysInMonth) {  /* По матиматическим правилом это можно записать и так  if (1 <= day <= daysInMonth). Как двойное не равенство day меньше 
                                              равно 1 или больше или равно daysInMonth. Но с точки зрения С++ это не правильная запись. Писать так можно и програма
                                              запуститься но будит понета не так, оно бы читалась как ((1 <= day) <= daysInMonth). с числом daysInMonth надо сравнить не
                                              число day, а результат его сравнения с числом 1. Делов том что с точки зрения С++ это выражения if (1 <= day <= daysInMonth)
                                              состоит из двух операций сравнения <= у которых одинаковый приаритет, а значит их нужно выполнить вполрят другом за другом.
                                              Поэтому для проверки лижит ли число в нужном диапозоне нужно использывать операцию (&& - и) */

    // То мы выводим "OK"
      std::cout << "OK";
      
    } else { // а если нет

    // аесли не поподает тогда "Eroor"
      std::cout << "Eroor";
    }
  }
}

                                                                    Резултат

Введите день, месяц и год: 40 5 2026
Eroor

                                                                    Резултат

Введите день, месяц и год: 29 2 2019
Eroor

                                                                    Резултат

Введите день, месяц и год: 20 2 2020
OK

В таблице перечислины операторы по убыванию приоритета. Если не уверен какой приоритет у операции всегда можно поставит скобки


                                                        Приоритеты операторов.


                            №     ЗНАК ДЕЙСТВИЙ                 ЧТО ДЕЛАЕТ

                            3           !                       отрицание

                            4           *                       умножение

                            5           /                       деление

                            6           %                       остаток от деления

                            7           +                       сложение

                            8           -                       вычитание

                            9           >                       больше

                            10          <                       меньше

                            11          >=                      больше или равно

                            12          <=                      меньше или равно

                            13          ==                      равенство

                            14          !=                      не равно

                            15          &&                      логическое И

                            16          ||                      логическое ИЛИ

                                                        ВОТ ПОЛНАЯ ТАБЛИЦА

                                                    https://en.cppreference.com/w/cpp/language/operator_precedence



                                                        Блоки и время жизни переменных.


                                                                ЗАДАЧА -6       (В макдональдсе продаются макнаггетсы в коробках по 6 и по 9 штук. Вася хочет купить
                                                                                 ровно N макнаггетсов. Напишите программу, которая по данному числу N проверяет,
                                                                                 получится ли у него это сделать.)